[{"title":"Error","type":0,"sectionRef":"#","url":"/Knit/api/Error","content":"On this page Error An object to represent runtime errors that occur during execution. Promises that experience an error like this will be rejected with an instance of this object.","keywords":""},{"title":"About","type":0,"sectionRef":"#","url":"/Knit/docs/intro","content":"","keywords":""},{"title":"Why Choose Knit?​","type":1,"pageTitle":"About","url":"/Knit/docs/intro#why-choose-knit","content":""},{"title":"Structure​","type":1,"pageTitle":"About","url":"/Knit/docs/intro#structure","content":"Services and controllers are the core of Knit. These objects provide a foundation for Roblox experiences. By orienting core game logic around services and controllers, developers will inherit cleaner organization across codebases and easier maintainability. Services and controllers are easy to create, and provide a built-in networking layer. "},{"title":"Networking Layer​","type":1,"pageTitle":"About","url":"/Knit/docs/intro#networking-layer","content":"Knit automatically provides networking between the client and services. Since Knit handles the networking infrastructure, developers are not left with the burden of manually creating RemoteEvent and RemoteFunction objects throughout the hierarchy. Each service has the ability to expose specific endpoints to the client through declarative code. "},{"title":"Extensible​","type":1,"pageTitle":"About","url":"/Knit/docs/intro#extensible","content":"Knit is built to be extensible. Developers write their own bootstrapping code to start and configure Knit, which gives developers the freedom to extend how Knit functions. "},{"title":"For Everyone​","type":1,"pageTitle":"About","url":"/Knit/docs/intro#for-everyone","content":"From professional game studios to independent developers, Knit offers a powerful and easy-to-use foundation for Roblox experiences. Knit is available from both Wally and from the Roblox library, allowing developers to choose between a Rojo-based or Studio-based workflow. "},{"title":"Widely Used​","type":1,"pageTitle":"About","url":"/Knit/docs/intro#widely-used","content":"Knit has been battle-tested in the Roblox ecosystem, and has proven itself to be reliable in both stability and scale. Knit is also open-source and encourages developers to contribute to the growth of the framework. "},{"title":"Comm","type":0,"sectionRef":"#","url":"/Knit/api/Comm","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Comm","url":"/Knit/api/Comm#properties","content":" "},{"title":"ServerComm​","type":1,"pageTitle":"Comm","url":"/Knit/api/Comm#ServerComm","content":"&lt;/&gt; Comm.ServerComm: ServerComm   "},{"title":"ClientComm​","type":1,"pageTitle":"Comm","url":"/Knit/api/Comm#ClientComm","content":"&lt;/&gt; Comm.ClientComm: ClientComm  "},{"title":"Loader","type":0,"sectionRef":"#","url":"/Knit/api/Loader","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Loader","url":"/Knit/api/Loader#types","content":" "},{"title":"PredicateFn​","type":1,"pageTitle":"Loader","url":"/Knit/api/Loader#PredicateFn","content":"&lt;/&gt; type PredicateFn = (module: ModuleScript ) → boolean Predicate function type. "},{"title":"Functions​","type":1,"pageTitle":"Loader","url":"/Knit/api/Loader#functions","content":" "},{"title":"LoadChildren​","type":1,"pageTitle":"Loader","url":"/Knit/api/Loader#LoadChildren","content":"&lt;/&gt; Loader.LoadChildren( parent: Instance , predicate: PredicateFn? ) → {[string]: any} Requires all children ModuleScripts. If a predicate function is provided, then the module will only be loaded if the predicate returns true for the the given ModuleScript. -- Load all ModuleScripts directly under MyModules: Loader.LoadChildren(ReplicatedStorage.MyModules) -- Load all ModuleScripts directly under MyModules if they have names ending in 'Service': Loader.LoadChildren(ReplicatedStorage.MyModules, function(moduleScript) return moduleScript.Name:match(&quot;Service$&quot;) ~= nil end)   "},{"title":"LoadDescendants​","type":1,"pageTitle":"Loader","url":"/Knit/api/Loader#LoadDescendants","content":"&lt;/&gt; Loader.LoadDescendants( parent: Instance , predicate: PredicateFn? ) → {[string]: any} Requires all descendant ModuleScripts. If a predicate function is provided, then the module will only be loaded if the predicate returns true for the the given ModuleScript. -- Load all ModuleScripts under MyModules: Loader.LoadDescendants(ReplicatedStorage.MyModules) -- Load all ModuleScripts under MyModules if they have names ending in 'Service': Loader.LoadDescendants(ReplicatedStorage.MyModules, function(moduleScript) return moduleScript.Name:match(&quot;Service$&quot;) ~= nil end)   "},{"title":"MatchesName​","type":1,"pageTitle":"Loader","url":"/Knit/api/Loader#MatchesName","content":"&lt;/&gt; Loader.MatchesName(matchName: string) → (module: ModuleScript ) → boolean A commonly-used predicate in the LoadChildren and LoadDescendants functions is one to match names. Therefore, the MatchesName utility function provides a quick way to create such predicates. Loader.LoadDescendants(ReplicatedStorage.MyModules, Loader.MatchesName(&quot;Service$&quot;))   "},{"title":"SpawnAll​","type":1,"pageTitle":"Loader","url":"/Knit/api/Loader#SpawnAll","content":"&lt;/&gt; Loader.SpawnAll( loadedModules: {[string]: any}, methodName: string ) → () Utility function for spawning a specific method in all given modules. If a module does not contain the specified method, it is simply skipped. Methods are called with task.spawn internally. For example, if the modules are expected to have an OnStart() method, then SpawnAll() could be used to start all of them directly after they have been loaded: local MyModules = ReplicatedStorage.MyModules -- Load all modules under MyModules and then call their OnStart methods: Loader.SpawnAll(Loader.LoadDescendants(MyModules), &quot;OnStart&quot;) -- Same as above, but only loads modules with names that end with Service: Loader.SpawnAll( Loader.LoadDescendants(MyModules, Loader.MatchesName(&quot;Service$&quot;)), &quot;OnStart&quot; )  "},{"title":"Execution Model","type":0,"sectionRef":"#","url":"/Knit/docs/executionmodel","content":"","keywords":""},{"title":"Lifecycle​","type":1,"pageTitle":"Execution Model","url":"/Knit/docs/executionmodel#lifecycle","content":"The execution model of Knit defines the flow of operations and lifecycle of Knit. Require the Knit moduleCreate services or controllersCall Knit.Start(), which immediately returns a Promise All KnitInit methods are invoked at the same time, and waits for all to finishAll KnitStart methods are invoked at the same time After all KnitStart methods are called, the promise returned by Knit.Start() resolves  On the server, you should have one Script in ServerScriptService. On the client, you should have one LocalScript in PlayerStarterScripts. Each of these scripts should have a similar layout: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Load services or controllers here Knit.Start():catch(warn)  Once services or controllers are created, they persist forever (until the server shuts down or the player leaves). caution Services and controllers cannot be created after Knit.Start() has been called. "},{"title":"Catching KnitInit Errors​","type":1,"pageTitle":"Execution Model","url":"/Knit/docs/executionmodel#catching-knitinit-errors","content":"Due to the way Promises work, errors that occur within KnitInit methods of services or controllers will be caught as a rejected promise. These can be handled by either grabbing the status after using Await or using the Catch() method: local success, err = Knit.Start():await() if not success then -- Handle error error(tostring(err)) end  Knit.Start():catch(function(err) -- Handle error warn(tostring(err)) end)  "},{"title":"Best Practices​","type":1,"pageTitle":"Execution Model","url":"/Knit/docs/executionmodel#best-practices","content":"Only one Script on the server should manage loading services and starting KnitOnly one LocalScript on the client should manage loading controllers and starting KnitSplit up services and controllers into their own modulesServices should be kept in either ServerStorage or ServerScriptService to avoid being exposed to the clientCode within KnitInit and within the root scope of the ModuleScript should try to finish ASAP, and should avoid yielding if possibleEvents and methods should never be added to a service's Client table after Knit.Start() has been calledAs shown above in the Catching knitInit Errors section, handling a failure case of Start is the cleanest way to catch errors on startup. "},{"title":"Util","type":0,"sectionRef":"#","url":"/Knit/docs/util","content":"","keywords":""},{"title":"Knit via Wally​","type":1,"pageTitle":"Util","url":"/Knit/docs/util#knit-via-wally","content":"When installing Knit with Wally, developers should pull in utility modules via Wally as required. Knit's utility modules are significantly slimmed down in the Wally release. "},{"title":"Knit via ModuleScript​","type":1,"pageTitle":"Util","url":"/Knit/docs/util#knit-via-modulescript","content":"Knit comes with a few utility modules. If Knit is being used from the packaged ModuleScript, then the best way to access these modules is via require(Knit.Util.PACKAGE). The following modules are available: Knit.Util.CommKnit.Util.ComponentKnit.Util.EnumListKnit.Util.InputKnit.Util.OptionKnit.Util.SignalKnit.Util.StreamableKnit.Util.TableUtilKnit.Util.TimerKnit.Util.TroveKnit.Util.Promise Below is an example of the Signal class being used in a service: local Signal = require(Knit.Util.Signal) local MyService = Knit.CreateService { Name = &quot;MyService&quot;, SomeSignal = Signal.new(), }  "},{"title":"ClientRemoteSignal","type":0,"sectionRef":"#","url":"/Knit/api/ClientRemoteSignal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ClientRemoteSignal","url":"/Knit/api/ClientRemoteSignal#types","content":" "},{"title":"Connection​","type":1,"pageTitle":"ClientRemoteSignal","url":"/Knit/api/ClientRemoteSignal#Connection","content":"&lt;/&gt; interface Connection { Disconnect: () → () } Represents a connection. "},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteSignal","url":"/Knit/api/ClientRemoteSignal#functions","content":" "},{"title":"Connect​","type":1,"pageTitle":"ClientRemoteSignal","url":"/Knit/api/ClientRemoteSignal#Connect","content":"&lt;/&gt; ClientRemoteSignal:Connect(fn: (...: any) → ()) → Connection Connects a function to the remote signal. The function will be called anytime the equivalent server-side RemoteSignal is fired at this specific client that created this client signal.  "},{"title":"Fire​","type":1,"pageTitle":"ClientRemoteSignal","url":"/Knit/api/ClientRemoteSignal#Fire","content":"&lt;/&gt; ClientRemoteSignal:Fire(...: any) → () Fires the equivalent server-side signal with the given arguments. Outbound Middleware All arguments pass through any outbound middleware before being sent to the server.  "},{"title":"Destroy​","type":1,"pageTitle":"ClientRemoteSignal","url":"/Knit/api/ClientRemoteSignal#Destroy","content":"&lt;/&gt; ClientRemoteSignal:Destroy() → () Destroys the ClientRemoteSignal object. "},{"title":"RemoteSignal","type":0,"sectionRef":"#","url":"/Knit/api/RemoteSignal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"RemoteSignal","url":"/Knit/api/RemoteSignal#types","content":" "},{"title":"Connection​","type":1,"pageTitle":"RemoteSignal","url":"/Knit/api/RemoteSignal#Connection","content":"&lt;/&gt; interface Connection { Disconnect: () → nil Connected: boolean } Represents a connection. "},{"title":"Functions​","type":1,"pageTitle":"RemoteSignal","url":"/Knit/api/RemoteSignal#functions","content":" "},{"title":"IsUnreliable​","type":1,"pageTitle":"RemoteSignal","url":"/Knit/api/RemoteSignal#IsUnreliable","content":"&lt;/&gt; RemoteSignal:IsUnreliable() → boolean Returns true if the underlying RemoteSignal is bound to an UnreliableRemoteEvent object.  "},{"title":"Connect​","type":1,"pageTitle":"RemoteSignal","url":"/Knit/api/RemoteSignal#Connect","content":"&lt;/&gt; RemoteSignal:Connect( fn: ( player: Player , ...: any ) → nil-- The function to connect ) → Connection Connect a function to the signal. Anytime a matching ClientRemoteSignal on a client fires, the connected function will be invoked with the arguments passed by the client.  "},{"title":"Fire​","type":1,"pageTitle":"RemoteSignal","url":"/Knit/api/RemoteSignal#Fire","content":"&lt;/&gt; RemoteSignal:Fire( player: Player ,-- The target client ...: any-- Arguments passed to the client ) → () Fires the signal at the specified client with any arguments. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireAll​","type":1,"pageTitle":"RemoteSignal","url":"/Knit/api/RemoteSignal#FireAll","content":"&lt;/&gt; RemoteSignal:FireAll(...: any) → () Fires the signal at all clients with any arguments. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireExcept​","type":1,"pageTitle":"RemoteSignal","url":"/Knit/api/RemoteSignal#FireExcept","content":"&lt;/&gt; RemoteSignal:FireExcept( ignorePlayer: Player ,-- The client to ignore ...: any-- Arguments passed to the other clients ) → () Fires the signal to all clients except the specified client. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireFilter​","type":1,"pageTitle":"RemoteSignal","url":"/Knit/api/RemoteSignal#FireFilter","content":"&lt;/&gt; RemoteSignal:FireFilter( predicate: ( player: Player , argsFromFire: ... ) → boolean, ...: any-- Arguments to pass to the clients (and to the predicate) ) → () Fires the signal at any clients that pass the predicate function test. This can be used to fire signals with much more control logic. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients. Predicate Before Middleware The arguments sent to the predicate are sent before getting transformed by any middleware. -- Fire signal to players of the same team: remoteSignal:FireFilter(function(player) return player.Team.Name == &quot;Best Team&quot; end)   "},{"title":"FireFor​","type":1,"pageTitle":"RemoteSignal","url":"/Knit/api/RemoteSignal#FireFor","content":"&lt;/&gt; RemoteSignal:FireFor( players: {Player }, ...: any ) → () Fires a signal at the clients within the players table. This is useful when signals need to fire for a specific set of players. For more complex firing, see FireFilter. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients. local players = {somePlayer1, somePlayer2, somePlayer3} remoteSignal:FireFor(players, &quot;Hello, players!&quot;)   "},{"title":"Destroy​","type":1,"pageTitle":"RemoteSignal","url":"/Knit/api/RemoteSignal#Destroy","content":"&lt;/&gt; RemoteSignal:Destroy() → () Destroys the RemoteSignal object. "},{"title":"ClientRemoteProperty","type":0,"sectionRef":"#","url":"/Knit/api/ClientRemoteProperty","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ClientRemoteProperty","url":"/Knit/api/ClientRemoteProperty#properties","content":" "},{"title":"Changed​","type":1,"pageTitle":"ClientRemoteProperty","url":"/Knit/api/ClientRemoteProperty#Changed","content":"&lt;/&gt; ClientRemoteProperty.Changed: Signal&lt;any&gt; Fires when the property receives an updated value from the server. clientRemoteProperty.Changed:Connect(function(value) print(&quot;New value&quot;, value) end)  "},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteProperty","url":"/Knit/api/ClientRemoteProperty#functions","content":" "},{"title":"Get​","type":1,"pageTitle":"ClientRemoteProperty","url":"/Knit/api/ClientRemoteProperty#Get","content":"&lt;/&gt; ClientRemoteProperty:Get() → any Gets the value of the property object. caution This value might not be ready right away. Use OnReady() or IsReady() before calling Get(). If not ready, this value will return nil.  "},{"title":"OnReady​","type":1,"pageTitle":"ClientRemoteProperty","url":"/Knit/api/ClientRemoteProperty#OnReady","content":"&lt;/&gt; ClientRemoteProperty:OnReady() → Promise&lt;any&gt; Returns a Promise which resolves once the property object is ready to be used. The resolved promise will also contain the value of the property. -- Use andThen clause: clientRemoteProperty:OnReady():andThen(function(initialValue) print(initialValue) end) -- Use await: local success, initialValue = clientRemoteProperty:OnReady():await() if success then print(initialValue) end   "},{"title":"IsReady​","type":1,"pageTitle":"ClientRemoteProperty","url":"/Knit/api/ClientRemoteProperty#IsReady","content":"&lt;/&gt; ClientRemoteProperty:IsReady() → boolean Returns true if the property object is ready to be used. In other words, it has successfully gained connection to the server-side version and has synced in the initial value. if clientRemoteProperty:IsReady() then local value = clientRemoteProperty:Get() end   "},{"title":"Observe​","type":1,"pageTitle":"ClientRemoteProperty","url":"/Knit/api/ClientRemoteProperty#Observe","content":"&lt;/&gt; ClientRemoteProperty:Observe(observer: (any) → nil) → Connection Observes the value of the property. The observer will be called right when the value is first ready, and every time the value changes. This is safe to call immediately (i.e. no need to use IsReady or OnReady before using this method). Observing is essentially listening to Changed, but also sends the initial value right away (or at least once OnReady is completed). local function ObserveValue(value) print(value) end clientRemoteProperty:Observe(ObserveValue)   "},{"title":"Destroy​","type":1,"pageTitle":"ClientRemoteProperty","url":"/Knit/api/ClientRemoteProperty#Destroy","content":"&lt;/&gt; ClientRemoteProperty:Destroy() → () Destroys the ClientRemoteProperty object. "},{"title":"Examples","type":0,"sectionRef":"#","url":"/Knit/docs/examples","content":"","keywords":""},{"title":"Start All Services​","type":1,"pageTitle":"Examples","url":"/Knit/docs/examples#start-all-services","content":"A useful pattern is to keep all service modules within a folder. The script that starts Knit can then require all of these at once. Let's say we have a directory structure like such: Server KnitRuntime [Script]Services [Folder] MyService [Module]AnotherService [Module]HelloService [Module] We can write our KnitRuntime script as such: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Load all services: for _, v in script.Parent.Services:GetDescendants() do if v:IsA(&quot;ModuleScript&quot;) then require(v) end end Knit.Start():catch(warn)  Alternatively, we can use Knit.AddServices or Knit.AddServicesDeep to load all of the services without writing a loop. It scans and loads all ModuleScripts found and passes them to Knit.CreateService: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Load all services within 'Services': Knit.AddServices(script.Parent.Services) -- Load all services (the Deep version scans all descendants of the passed instance): Knit.AddServicesDeep(script.Parent.OtherServices) Knit.Start():catch(warn)  tip This same design practice can also be done on the client with controllers. Either loop through and collect controllers or use the Knit.AddControllers or Knit.AddControllersDeep function.  "},{"title":"Expose a Collection of Modules​","type":1,"pageTitle":"Examples","url":"/Knit/docs/examples#expose-a-collection-of-modules","content":"Like Knit.Util, we can expose a collection of modules to our codebase. This is very simple. All we need to do is add Knit.WHATEVER and point it to a folder of ModuleScripts. For instance, if we had a folder of modules at ReplicatedStorage.MyModules, we can expose this within our main runtime script: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Expose our MyModules folder: Knit.MyModules = game:GetService(&quot;ReplicatedStorage&quot;).MyModules -- Load services/controllers Knit.Start()  We can then use these modules elsewhere. For instance: local SomeModule = require(Knit.MyModules.SomeModule)  "},{"title":"Controllers","type":0,"sectionRef":"#","url":"/Knit/docs/controllers","content":"","keywords":""},{"title":"Controllers Defined​","type":1,"pageTitle":"Controllers","url":"/Knit/docs/controllers#controllers-defined","content":"Controllers are singleton provider objects that serve a specific purpose on the client. For instance, a game might have a CameraController, which manages a custom in-game camera for the player. A controller is essentially the client-side equivalent of a service on the server. For the sake of example, we will develop a CameraController. "},{"title":"Creating Controllers​","type":1,"pageTitle":"Controllers","url":"/Knit/docs/controllers#creating-controllers","content":"In its simplest form, a controller can be created like so: local CameraController = Knit.CreateController { Name = &quot;CameraController&quot; } return CameraController  The Name field is required. The name is how code outside of your controller will find it. This name must be unique from all other controllers. It is best practice to name your variable the same as the controller (e.g. local CameraController matches Name = &quot;CameraController&quot;). The last line (return CameraController) assumes this code is written in a ModuleScript, which is best practice for containing controllers. "},{"title":"Adding Methods​","type":1,"pageTitle":"Controllers","url":"/Knit/docs/controllers#adding-methods","content":"Controllers are just simple tables at the end of the day. As such, it is very easy to add methods to controllers. function CameraController:LockTo(part) -- TODO: Lock camera end function CameraController:Unlock() -- TODO: Unlock end  "},{"title":"Adding Properties​","type":1,"pageTitle":"Controllers","url":"/Knit/docs/controllers#adding-properties","content":"Again, controllers are just tables. We can simply add in properties as we want. Let's add a property to describe how far away our camera should be from the part we lock onto, and another to describe if the camera is currently locked: CameraController.Distance = 20 CameraController.Locked = false  "},{"title":"Adding Basic Behavior​","type":1,"pageTitle":"Controllers","url":"/Knit/docs/controllers#adding-basic-behavior","content":"Let's add some basic behavior to our controller. When the camera is locked, we should set the CurrentCamera's CameraType to Scriptable, and set the CFrame to the part. When unlocked, we should set the CameraType back to Custom. We will also utilize the Locked property so other code can check if we are currently locked to a part. function CameraController:LockTo(part) local cam = workspace.CurrentCamera self.Locked = true cam.CameraType = Enum.CameraType.Scriptable cam.CFrame = part.CFrame * CFrame.new(0, 0, self.Distance) end function CameraController:Unlock() local cam = workspace.CurrentCamera self.Locked = false cam.CameraType = Enum.CameraType.Custom end  "},{"title":"More Behavior​","type":1,"pageTitle":"Controllers","url":"/Knit/docs/controllers#more-behavior","content":"Right now, when we lock onto a part, we simply set the camera's CFrame once. But what if the part moves? We need to constantly set the camera's CFrame to properly lock onto the part. We can bind to RenderStep to do this. local RunService = game:GetService(&quot;RunService&quot;) CameraController.RenderName = &quot;CustomCamRender&quot; CameraController.Priority = Enum.RenderPriority.Camera.Value function CameraController:LockTo(part) if (self.Locked) then return end -- Stop if already locked local cam = workspace.CurrentCamera self.Locked = true cam.CameraType = Enum.CameraType.Scriptable -- Bind to RenderStep: RunService:BindToRenderStep(self.RenderName, self.Priority, function() cam.CFrame = part.CFrame * CFrame.new(0, 0, self.Distance) end) end function CameraController:Unlock() if (not self.Locked) then return end -- Stop if already unlocked local cam = workspace.CurrentCamera self.Locked = false cam.CameraType = Enum.CameraType.Custom -- Unbind: RunService:UnbindFromRenderStep(self.RenderName) end  "},{"title":"Events​","type":1,"pageTitle":"Controllers","url":"/Knit/docs/controllers#events","content":"What if we want to create an event that gets fired when the camera is locked and unlocked? We can easily do this! Just create a new signal object as a property of the controller, and fire it in our LockTo and Unlock methods. Let's created a LockedChanged signal. It will pass true when locked and false when unlocked. local Signal = require(Knit.Util.Signal) CameraController.LockedChanged = Signal.new() function CameraController:LockTo(part) -- Other code... self.LockedChanged:Fire(true) end function CameraController:Unlock() -- Other code... self.LockedChanged:Fire(false) end  Other code could then listen in for that event: -- Somewhere else on the client local CameraController = Knit.GetController(&quot;CameraController&quot;) CameraController.LockedChanged:Connect(function(isLocked) print(if isLocked then &quot;Camera is now locked&quot; else &quot;Camera was unlocked&quot;) end)  "},{"title":"Server Communication​","type":1,"pageTitle":"Controllers","url":"/Knit/docs/controllers#server-communication","content":"Knit allows client code to access certain server-side service methods and events that have been explicitly exposed. See the Services: Client Communication section for more info. An example of accessing a service on the server might look like such: function CameraController:KnitStart() local SomeService = Knit.GetService(&quot;SomeService&quot;) SomeService:DoSomething() SomeService.SomeEvent:Connect(function(...) end) SomeService.AnotherEvent:Fire(&quot;Some data&quot;) end  No client table forces server-only mode If the Client table is omitted from the service, the service will be interpreted as server-side only. This means that the client will not be able to access the service using Knit.GetService on the client if there is no Client table present. "},{"title":"KnitInit and KnitStart​","type":1,"pageTitle":"Controllers","url":"/Knit/docs/controllers#knitinit-and-knitstart","content":"The KnitInit and KnitStart methods are optional lifecycle methods that can be added to any controller. For more info, check out the service version of this section (which has the same behavior) and the execution model. These methods can be added just like any other method: function CameraController:KnitStart() print(&quot;CameraController KnitStart called&quot;) end function CameraController:KnitInit() print(&quot;CameraController KnitInit called&quot;) end  "},{"title":"RemoteProperty","type":0,"sectionRef":"#","url":"/Knit/api/RemoteProperty","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"RemoteProperty","url":"/Knit/api/RemoteProperty#functions","content":" "},{"title":"Set​","type":1,"pageTitle":"RemoteProperty","url":"/Knit/api/RemoteProperty#Set","content":"&lt;/&gt; RemoteProperty:Set(value: any) → () Sets the top-level value of all clients to the same value. Override Per-Player Data This will override any per-player data that was set usingSetFor or SetFilter. To avoid overriding this data, SetTop can be used instead. -- Examples remoteProperty:Set(10) remoteProperty:Set({SomeData = 32}) remoteProperty:Set(&quot;HelloWorld&quot;)   "},{"title":"SetTop​","type":1,"pageTitle":"RemoteProperty","url":"/Knit/api/RemoteProperty#SetTop","content":"&lt;/&gt; RemoteProperty:SetTop(value: any) → () Set the top-level value of the property, but does not override any per-player data (e.g. set with SetFor or SetFilter). Any player without custom-set data will receive this new data. This is useful if certain players have specific values that should not be changed, but all other players should receive the same new value. -- Using just 'Set' overrides per-player data: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot; -- Using 'SetTop' does not override: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:SetTop(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot;   "},{"title":"SetFilter​","type":1,"pageTitle":"RemoteProperty","url":"/Knit/api/RemoteProperty#SetFilter","content":"&lt;/&gt; RemoteProperty:SetFilter( predicate: ( Player , any ) → boolean, value: any-- Value to set for the clients (and to the predicate) ) → () Sets the value for specific clients that pass the predicate function test. This can be used to finely set the values based on more control logic (e.g. setting certain values per team). -- Set the value of &quot;NewValue&quot; to players with a name longer than 10 characters: remoteProperty:SetFilter(function(player) return #player.Name &gt; 10 end, &quot;NewValue&quot;)   "},{"title":"SetFor​","type":1,"pageTitle":"RemoteProperty","url":"/Knit/api/RemoteProperty#SetFor","content":"&lt;/&gt; RemoteProperty:SetFor( player: Player , value: any ) → () Set the value of the property for a specific player. This will override the value used by Set (and the initial value set for the property when created). This value can be nil. In order to reset the value for a given player and let the player use the top-level value held by this property, either use Set to set all players' data, or use ClearFor. remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;)   "},{"title":"SetForList​","type":1,"pageTitle":"RemoteProperty","url":"/Knit/api/RemoteProperty#SetForList","content":"&lt;/&gt; RemoteProperty:SetForList( players: {Player }, value: any ) → () Set the value of the property for specific players. This just loops through the players given and calls SetFor. local players = {player1, player2, player3} remoteProperty:SetForList(players, &quot;CustomData&quot;)   "},{"title":"ClearFor​","type":1,"pageTitle":"RemoteProperty","url":"/Knit/api/RemoteProperty#ClearFor","content":"&lt;/&gt; RemoteProperty:ClearFor(player: Player ) → () Clears the custom property value for the given player. When this occurs, the player will reset to use the top-level value held by this property (either the value set when the property was created, or the last value set by Set). remoteProperty:Set(&quot;DATA&quot;) remoteProperty:SetFor(somePlayer, &quot;CUSTOM_DATA&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CUSTOM_DATA&quot; -- DOES NOT CLEAR, JUST SETS CUSTOM DATA TO NIL: remoteProperty:SetFor(somePlayer, nil) print(remoteProperty:GetFor(somePlayer)) --&gt; nil -- CLEAR: remoteProperty:ClearFor(somePlayer) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;DATA&quot;   "},{"title":"ClearForList​","type":1,"pageTitle":"RemoteProperty","url":"/Knit/api/RemoteProperty#ClearForList","content":"&lt;/&gt; RemoteProperty:ClearForList(players: {Player }) → () Clears the custom value for the given players. This just loops through the list of players and calls the ClearFor method for each player.  "},{"title":"ClearFilter​","type":1,"pageTitle":"RemoteProperty","url":"/Knit/api/RemoteProperty#ClearFilter","content":"&lt;/&gt; RemoteProperty:ClearFilter(predicate: (Player ) → boolean) → () The same as SetFiler, except clears the custom value for any player that passes the predicate.  "},{"title":"Get​","type":1,"pageTitle":"RemoteProperty","url":"/Knit/api/RemoteProperty#Get","content":"&lt;/&gt; RemoteProperty:Get() → any Returns the top-level value held by the property. This will either be the initial value set, or the last value set with Set(). remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:Get()) --&gt; &quot;Data&quot;   "},{"title":"GetFor​","type":1,"pageTitle":"RemoteProperty","url":"/Knit/api/RemoteProperty#GetFor","content":"&lt;/&gt; RemoteProperty:GetFor(player: Player ) → any Returns the current value for the given player. This value will depend on if SetFor or SetFilter has affected the custom value for the player. If so, that custom value will be returned. Otherwise, the top-level value will be used (e.g. value from Set). -- Set top level data: remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot; -- Set custom data: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot; -- Set top level again, overriding custom data: remoteProperty:Set(&quot;NewData&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;NewData&quot; -- Set custom data again, and set top level without overriding: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:SetTop(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot; -- Clear custom data to use top level data: remoteProperty:ClearFor(somePlayer) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot;   "},{"title":"Destroy​","type":1,"pageTitle":"RemoteProperty","url":"/Knit/api/RemoteProperty#Destroy","content":"&lt;/&gt; RemoteProperty:Destroy() → () Destroys the RemoteProperty object. "},{"title":"ServerComm","type":0,"sectionRef":"#","url":"/Knit/api/ServerComm","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ServerComm","url":"/Knit/api/ServerComm#types","content":" "},{"title":"ServerMiddlewareFn​","type":1,"pageTitle":"ServerComm","url":"/Knit/api/ServerComm#ServerMiddlewareFn","content":"&lt;/&gt; type ServerMiddlewareFn = ( player: Player , args: {any} ) → ( shouldContinue: boolean, ...: any ) The middleware function takes the client player and the arguments (as a table array), and should return true|false to indicate if the process should continue. If returning false, the optional varargs after the false are used as the new return values to whatever was calling the middleware.  "},{"title":"ServerMiddleware​","type":1,"pageTitle":"ServerComm","url":"/Knit/api/ServerComm#ServerMiddleware","content":"&lt;/&gt; type ServerMiddleware = {ServerMiddlewareFn} Array of middleware functions. "},{"title":"Functions​","type":1,"pageTitle":"ServerComm","url":"/Knit/api/ServerComm#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ServerComm","url":"/Knit/api/ServerComm#new","content":"&lt;/&gt; ServerComm.new( parent: Instance , namespace: string? ) → ServerComm Constructs a ServerComm object. The namespace parameter is used in cases where more than one ServerComm object may be bound to the same object. Otherwise, a default namespace is used. local serverComm = ServerComm.new(game:GetService(&quot;ReplicatedStorage&quot;)) -- If many might exist in the given parent, use a unique namespace: local serverComm = ServerComm.new(game:GetService(&quot;ReplicatedStorage&quot;), &quot;MyNamespace&quot;)   "},{"title":"BindFunction​","type":1,"pageTitle":"ServerComm","url":"/Knit/api/ServerComm#BindFunction","content":"&lt;/&gt; ServerComm:BindFunction( name: string, fn: ( player: Player , ...: any ) → ...: any, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteFunction  Creates a RemoteFunction and binds the given function to it. Inbound and outbound middleware can be applied if desired. local function GetSomething(player: Player) return &quot;Something&quot; end serverComm:BindFunction(&quot;GetSomething&quot;, GetSomething)   "},{"title":"WrapMethod​","type":1,"pageTitle":"ServerComm","url":"/Knit/api/ServerComm#WrapMethod","content":"&lt;/&gt; ServerComm:WrapMethod( tbl: table, name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteFunction  Binds a function to a table method. The name must match the name of the method in the table. The same name will be used on the client to access the given function. local MyObject = { _Data = 10, } function MyObject:GetData(player: Player) return self._Data end serverComm:WrapMethod(MyObject, &quot;GetData&quot;)   "},{"title":"CreateSignal​","type":1,"pageTitle":"ServerComm","url":"/Knit/api/ServerComm#CreateSignal","content":"&lt;/&gt; ServerComm:CreateSignal( name: string, unreliable: boolean?, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteSignal Creates a signal that can be used to fire data to the clients or receive data from the clients. By default, signals use RemoteEvents internally. However, if the unreliable argument is set to true, then an UnreliableRemoteEvent will be used instead. local mySignal = serverComm:CreateSignal(&quot;MySignal&quot;) -- Examples of firing in different ways (see docs for RemoteSignal for further info): mySignal:Fire(somePlayer, &quot;Hello world&quot;) mySignal:FireAll(&quot;Hi there&quot;) mySignal:FireExcept(somePlayer, &quot;Hello everyone except &quot; .. somePlayer.Name) mySignal:FireFilter(function(player) return player.Team == someCoolTeam end, &quot;Hello cool team&quot;) -- Example of listening for clients to send data: mySignal:Connect(function(player, message) print(&quot;Got a message from &quot; .. player.Name .. &quot;:&quot;, message) end)   "},{"title":"CreateProperty​","type":1,"pageTitle":"ServerComm","url":"/Knit/api/ServerComm#CreateProperty","content":"&lt;/&gt; ServerComm:CreateProperty( name: string, initialValue: any, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteProperty Create a property object which will replicate its property value to the clients. Optionally, specific clients can be targeted with different property values. local comm = Comm.ServerComm.new(game:GetService(&quot;ReplicatedStorage&quot;)) local mapInfo = comm:CreateProperty(&quot;MapInfo&quot;, { MapName = &quot;TheAwesomeMap&quot;, MapDuration = 60, }) -- Change the data: mapInfo:Set({ MapName = &quot;AnotherMap&quot;, MapDuration = 30, }) -- Change the data for one player: mapInfo:SetFor(somePlayer, { MapName = &quot;ASpecialMapForYou&quot;, MapDuration = 90, }) -- Change data based on a predicate function: mapInfo:SetFilter(function(player) return player.Team == game.Teams.SomeSpecialTeam end, { MapName = &quot;TeamMap&quot;, MapDuration = 20, })   "},{"title":"Destroy​","type":1,"pageTitle":"ServerComm","url":"/Knit/api/ServerComm#Destroy","content":"&lt;/&gt; ServerComm:Destroy() → () Destroy the ServerComm object. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/Knit/docs/gettingstarted","content":"","keywords":""},{"title":"Tutorial Videos​","type":1,"pageTitle":"Getting Started","url":"/Knit/docs/gettingstarted#tutorial-videos","content":"Knit can be used via two workflows: Roblox Studio and externally with Rojo and Wally. To help explain how Knit is used through both workflows, check out the tutorial videos for each: Knit Tutorial for StudioKnit Tutorial for Rojo/Wally "},{"title":"Install​","type":1,"pageTitle":"Getting Started","url":"/Knit/docs/gettingstarted#install","content":"Installing Knit is very simple. Just drop the module into ReplicatedStorage. Knit can also be used within a Rojo project. Roblox Studio workflow: Get Knit from the Roblox library.Place Knit directly within ReplicatedStorage. Rojo/Wally workflow: Add Knit to your wally.toml dependency list (e.g. Knit = &quot;Breezy1214/knit@^1.7&quot;) Require Knit like any other module grabbed from Wally Wally Not familiar with Wally? Wally is a package manager (like NPM) for the Roblox ecosystem. To get started, check out the Wally repository. "},{"title":"Basic Usage​","type":1,"pageTitle":"Getting Started","url":"/Knit/docs/gettingstarted#basic-usage","content":"The core usage of Knit is the same from the server and the client. The general pattern is to create a single script on the server and a single script on the client. These scripts will load Knit, create services/controllers, and then start Knit. The most basic usage would look as such: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) Knit.Start():catch(warn) -- Knit.Start() returns a Promise, so we are catching any errors and feeding it to the built-in 'warn' function -- You could also chain 'await()' to the end to yield until the whole sequence is completed: -- Knit.Start():catch(warn):await()  That would be the necessary code on both the server and the client. However, nothing interesting is going to happen. Let's dive into some more examples. "},{"title":"A Simple Service​","type":1,"pageTitle":"Getting Started","url":"/Knit/docs/gettingstarted#a-simple-service","content":"A service is simply a structure that serves some specific purpose. For instance, a game might have a MoneyService, which manages in-game currency for players. Let's look at a simple example: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Create the service: local MoneyService = Knit.CreateService { Name = &quot;MoneyService&quot;, } -- Add some methods to the service: function MoneyService:GetMoney(player) -- Do some sort of data fetch local money = someDataStore:GetAsync(&quot;money&quot;) return money end function MoneyService:GiveMoney(player, amount) -- Do some sort of data fetch local money = self:GetMoney(player) money += amount someDataStore:SetAsync(&quot;money&quot;, money) end Knit.Start():catch(warn)  note It's better practice to put services and controllers within their own ModuleScript and then require them from your main script. For the sake of simplicity, they are all in one script for these examples. Now we have a little MoneyService that can get and give money to a player. However, only the server can use this at the moment. What if we want clients to fetch how much money they have? To do this, we have to create some client-side code to consume our service. We could create a controller, but it's not necessary for this example. First, we need to expose a method to the client. We can do this by writing methods on the service's Client table: -- Money service on the server ... function MoneyService.Client:GetMoney(player) -- We already wrote this method, so we can just call the other one. -- 'self.Server' will reference back to the root MoneyService. return self.Server:GetMoney(player) end ...  We can write client-side code to fetch money from the service: -- Client-side code local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) Knit.Start():catch(warn):await() local MoneyService = Knit.GetService(&quot;MoneyService&quot;) MoneyService:GetMoney():andThen(function(money) print(money) end) -- Don't want to use promises? When you start Knit on the client, -- set the ServicePromises option to false:  Turn Off Promises Don't want to use promises when the client calls a service method? Set the ServicePromises option to false when you start Knit on the client: Knit.Start({ServicePromises = false}):catch(warn):await() local MoneyService = Knit.GetService(&quot;MoneyService&quot;) local money = MoneyService:GetMoney()  Under the hood, Knit is creating a RemoteFunction bound to the service's GetMoney method. Knit keeps RemoteFunctions and RemoteEvents out of the way so that developers can focus on writing code and not building communication infrastructure. Check out the Services documentation for more info on services. "},{"title":"KnitClient","type":0,"sectionRef":"#","url":"/Knit/api/KnitClient","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#types","content":" "},{"title":"ClientMiddlewareFn​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#ClientMiddlewareFn","content":"&lt;/&gt; type ClientMiddlewareFn = (args: {any}) → ( shouldContinue: boolean, ...: any ) For more info, see ClientComm documentation.  "},{"title":"ClientMiddleware​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#ClientMiddleware","content":"&lt;/&gt; type ClientMiddleware = {ClientMiddlewareFn} An array of client middleware functions.  "},{"title":"PerServiceMiddleware​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#PerServiceMiddleware","content":"&lt;/&gt; type PerServiceMiddleware = {[string]: Middleware}   "},{"title":"ControllerDef​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#ControllerDef","content":"&lt;/&gt; interface ControllerDef { Name: string [any]: any } Used to define a controller when creating it in CreateController.  "},{"title":"Controller​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#Controller","content":"&lt;/&gt; interface Controller { Name: string [any]: any }   "},{"title":"KnitClientOptions​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#KnitClientOptions","content":"&lt;/&gt; interface KnitClientOptions { ServicePromises: boolean? Middleware: Middleware? PerServiceMiddleware: PerServiceMiddleware? } ServicePromises defaults to true and indicates if service methods use promises. Each service will go through the defined middleware, unless the service has middleware defined in PerServiceMiddleware.   "},{"title":"Middleware​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#Middleware","content":"&lt;/&gt; interface Middleware { Inbound: ClientMiddleware? Outbound: ClientMiddleware? }  "},{"title":"Properties​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#properties","content":" "},{"title":"Player​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#Player","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; KnitClient.Player: Player  Reference to the LocalPlayer.  "},{"title":"Util​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#Util","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; KnitClient.Util: Folder  References the Util folder. Should only be accessed when using Knit as a standalone module. If using Knit from Wally, modules should just be pulled in via Wally instead of relying on Knit's Util folder, as this folder only contains what is necessary for Knit to run in Wally mode. "},{"title":"Functions​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#functions","content":" "},{"title":"CreateController​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#CreateController","content":"&lt;/&gt; KnitClient.CreateController(controllerDef: ControllerDef) → Controller Creates a new controller. caution Controllers must be created before calling Knit.Start(). -- Create a controller local MyController = Knit.CreateController { Name = &quot;MyController&quot;, } function MyController:KnitStart() print(&quot;MyController started&quot;) end function MyController:KnitInit() print(&quot;MyController initialized&quot;) end   "},{"title":"AddControllers​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#AddControllers","content":"&lt;/&gt; KnitClient.AddControllers(parent: Instance ) → {Controller} Requires all the modules that are children of the given parent. This is an easy way to quickly load all controllers that might be in a folder. Knit.AddControllers(somewhere.Controllers)   "},{"title":"AddControllersDeep​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#AddControllersDeep","content":"&lt;/&gt; KnitClient.AddControllersDeep(parent: Instance ) → {Controller} Requires all the modules that are descendants of the given parent.  "},{"title":"GetService​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#GetService","content":"&lt;/&gt; KnitClient.GetService(serviceName: string) → ClientService "},{"title":"Types","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient##","content":""},{"title":"​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#Service","content":"interface Service { [any]: any }  Returns a Service object which is a reflection of the remote objects within the Client table of the given service. Throws an error if the service is not found. If a service's Client table contains RemoteSignals and/or RemoteProperties, these values are reflected asClientRemoteSignals and ClientRemoteProperties. -- Server-side service creation: local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = { MySignal = Knit.CreateSignal(), MyProperty = Knit.CreateProperty(&quot;Hello&quot;), }, } function MyService:AddOne(player, number) return number + 1 end ------------------------------------------------- -- Client-side service reflection: local MyService = Knit.GetService(&quot;MyService&quot;) -- Call a method: local num = MyService:AddOne(5) --&gt; 6 -- Fire a signal to the server: MyService.MySignal:Fire(&quot;Hello&quot;) -- Listen for signals from the server: MyService.MySignal:Connect(function(message) print(message) end) -- Observe the initial value and changes to properties: MyService.MyProperty:Observe(function(value) print(value) end) caution Services are only exposed to the client if the service has remote-based content in the Client table. If not, the service will not be visible to the client. KnitClient.GetService will only work on services that expose remote-based content on their Client tables.  "},{"title":"GetController​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#GetController","content":"&lt;/&gt; KnitClient.GetController(controllerName: string) → Controller Gets the controller by name. Throws an error if the controller is not found.  "},{"title":"GetControllers​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#GetControllers","content":"&lt;/&gt; KnitClient.GetControllers() → {[string]: Controller} Gets a table of all controllers.  "},{"title":"Start​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#Start","content":"&lt;/&gt; KnitClient.Start(options: KnitClientOptions?) → Promise Starts Knit. Should only be called once per client. Knit.Start():andThen(function() print(&quot;Knit started!&quot;) end):catch(warn) By default, service methods exposed to the client will return promises. To change this behavior, set the ServicePromises option to false: Knit.Start({ServicePromises = false}):andThen(function() print(&quot;Knit started!&quot;) end):catch(warn)   "},{"title":"OnStart​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#OnStart","content":"&lt;/&gt; KnitClient.OnStart() → Promise Returns a promise that is resolved once Knit has started. This is useful for any code that needs to tie into Knit controllers but is not the script that called Start. Knit.OnStart():andThen(function() local MyController = Knit.GetController(&quot;MyController&quot;) MyController:DoSomething() end):catch(warn)  "},{"title":"ClientComm","type":0,"sectionRef":"#","url":"/Knit/api/ClientComm","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ClientComm","url":"/Knit/api/ClientComm#types","content":" "},{"title":"ClientMiddlewareFn​","type":1,"pageTitle":"ClientComm","url":"/Knit/api/ClientComm#ClientMiddlewareFn","content":"&lt;/&gt; type ClientMiddlewareFn = (args: {any}) → ( shouldContinue: boolean, ...: any ) The middleware function takes the arguments (as a table array), and should return true|false to indicate if the process should continue. If returning false, the optional varargs after the false are used as the new return values to whatever was calling the middleware.  "},{"title":"ClientMiddleware​","type":1,"pageTitle":"ClientComm","url":"/Knit/api/ClientComm#ClientMiddleware","content":"&lt;/&gt; type ClientMiddleware = {ClientMiddlewareFn} Array of middleware functions. "},{"title":"Functions​","type":1,"pageTitle":"ClientComm","url":"/Knit/api/ClientComm#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ClientComm","url":"/Knit/api/ClientComm#new","content":"&lt;/&gt; ClientComm.new( parent: Instance , usePromise: boolean, namespace: string? ) → ClientComm Constructs a ClientComm object. If usePromise is set to true, then GetFunction will generate a function that returns a Promise that resolves with the server response. If set to false, the function will act like a normal call to a RemoteFunction and yield until the function responds. local clientComm = ClientComm.new(game:GetService(&quot;ReplicatedStorage&quot;), true) -- If using a unique namespace with ServerComm, include it as second argument: local clientComm = ClientComm.new(game:GetService(&quot;ReplicatedStorage&quot;), true, &quot;MyNamespace&quot;)   "},{"title":"GetFunction​","type":1,"pageTitle":"ClientComm","url":"/Knit/api/ClientComm#GetFunction","content":"&lt;/&gt; ClientComm:GetFunction( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → (...: any) → any Generates a function on the matching RemoteFunction generated with ServerComm. The function can then be called to invoke the server. If this ClientComm object was created with the usePromise parameter set to true, then this generated function will return a Promise when called. -- Server-side: local serverComm = ServerComm.new(someParent) serverComm:BindFunction(&quot;MyFunction&quot;, function(player, msg) return msg:upper() end) -- Client-side: local clientComm = ClientComm.new(someParent) local myFunc = clientComm:GetFunction(&quot;MyFunction&quot;) local uppercase = myFunc(&quot;hello world&quot;) print(uppercase) --&gt; HELLO WORLD -- Client-side, using promises: local clientComm = ClientComm.new(someParent, true) local myFunc = clientComm:GetFunction(&quot;MyFunction&quot;) myFunc(&quot;hi there&quot;):andThen(function(msg) print(msg) --&gt; HI THERE end):catch(function(err) print(&quot;Error:&quot;, err) end)   "},{"title":"GetSignal​","type":1,"pageTitle":"ClientComm","url":"/Knit/api/ClientComm#GetSignal","content":"&lt;/&gt; ClientComm:GetSignal( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → ClientRemoteSignal Returns a new ClientRemoteSignal that mirrors the matching RemoteSignal created by ServerComm with the same matching name. local mySignal = clientComm:GetSignal(&quot;MySignal&quot;) -- Listen for data from the server: mySignal:Connect(function(message) print(&quot;Received message from server:&quot;, message) end) -- Send data to the server: mySignal:Fire(&quot;Hello!&quot;)   "},{"title":"GetProperty​","type":1,"pageTitle":"ClientComm","url":"/Knit/api/ClientComm#GetProperty","content":"&lt;/&gt; ClientComm:GetProperty( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → ClientRemoteProperty Returns a new ClientRemoteProperty that mirrors the matching RemoteProperty created by ServerComm with the same matching name. Take a look at the ClientRemoteProperty documentation for more info, such as understanding how to wait for data to be ready. local mapInfo = clientComm:GetProperty(&quot;MapInfo&quot;) -- Observe the initial value of mapInfo, and all subsequent changes: mapInfo:Observe(function(info) print(&quot;Current map info&quot;, info) end) -- Check to see if data is initially ready: if mapInfo:IsReady() then -- Get the data: local info = mapInfo:Get() end -- Get a promise that resolves once the data is ready (resolves immediately if already ready): mapInfo:OnReady():andThen(function(info) print(&quot;Map info is ready with info&quot;, info) end) -- Same as above, but yields thread: local success, info = mapInfo:OnReady():await()   "},{"title":"BuildObject​","type":1,"pageTitle":"ClientComm","url":"/Knit/api/ClientComm#BuildObject","content":"&lt;/&gt; ClientComm:BuildObject( inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → table Returns an object which maps RemoteFunctions as methods and RemoteEvents as fields. -- Server-side: serverComm:BindFunction(&quot;Test&quot;, function(player) end) serverComm:CreateSignal(&quot;MySignal&quot;) serverComm:CreateProperty(&quot;MyProperty&quot;, 10) -- Client-side local obj = clientComm:BuildObject() obj:Test() obj.MySignal:Connect(function(data) end) obj.MyProperty:Observe(function(value) end)   "},{"title":"Destroy​","type":1,"pageTitle":"ClientComm","url":"/Knit/api/ClientComm#Destroy","content":"&lt;/&gt; ClientComm:Destroy() → () Destroys the ClientComm object. "},{"title":"Signal","type":0,"sectionRef":"#","url":"/Knit/api/Signal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Signal","url":"/Knit/api/Signal#types","content":" "},{"title":"SignalConnection​","type":1,"pageTitle":"Signal","url":"/Knit/api/Signal#SignalConnection","content":"&lt;/&gt; interface SignalConnection { Connected: boolean Disconnect: (SignalConnection) → () } Represents a connection to a signal. local connection = signal:Connect(function() end) print(connection.Connected) --&gt; true connection:Disconnect() print(connection.Connected) --&gt; false   "},{"title":"ConnectionFn​","type":1,"pageTitle":"Signal","url":"/Knit/api/Signal#ConnectionFn","content":"&lt;/&gt; type ConnectionFn = (...any) → () A function connected to a signal. "},{"title":"Functions​","type":1,"pageTitle":"Signal","url":"/Knit/api/Signal#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Signal","url":"/Knit/api/Signal#new","content":"&lt;/&gt; Signal.new() → Signal Constructs a new Signal  "},{"title":"Wrap​","type":1,"pageTitle":"Signal","url":"/Knit/api/Signal#Wrap","content":"&lt;/&gt; Signal.Wrap( rbxScriptSignal: RBXScriptSignal -- Existing RBXScriptSignal to wrap ) → Signal Constructs a new Signal that wraps around an RBXScriptSignal. For example: local signal = Signal.Wrap(workspace.ChildAdded) signal:Connect(function(part) print(part.Name .. &quot; added&quot;) end) Instance.new(&quot;Part&quot;).Parent = workspace   "},{"title":"Is​","type":1,"pageTitle":"Signal","url":"/Knit/api/Signal#Is","content":"&lt;/&gt; Signal.Is( obj: any-- Object to check ) → boolean-- true if the object is a Signal. Checks if the given object is a Signal.  "},{"title":"Connect​","type":1,"pageTitle":"Signal","url":"/Knit/api/Signal#Connect","content":"&lt;/&gt; Signal:Connect(fn: ConnectionFn) → SignalConnection Connects a function to the signal, which will be called anytime the signal is fired. signal:Connect(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25)   "},{"title":"Once​","type":1,"pageTitle":"Signal","url":"/Knit/api/Signal#Once","content":"&lt;/&gt; Signal:Once(fn: ConnectionFn) → SignalConnection Connects a function to the signal, which will be called the next time the signal fires. Once the connection is triggered, it will disconnect itself. signal:Once(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25) signal:Fire(&quot;This message will not go through&quot;, 10)   "},{"title":"DisconnectAll​","type":1,"pageTitle":"Signal","url":"/Knit/api/Signal#DisconnectAll","content":"&lt;/&gt; Signal:DisconnectAll() → () Disconnects all connections from the signal. signal:DisconnectAll()   "},{"title":"Fire​","type":1,"pageTitle":"Signal","url":"/Knit/api/Signal#Fire","content":"&lt;/&gt; Signal:Fire(...: any) → () Fire the signal, which will call all of the connected functions with the given arguments. signal:Fire(&quot;Hello&quot;) -- Any number of arguments can be fired: signal:Fire(&quot;Hello&quot;, 32, {Test = &quot;Test&quot;}, true)   "},{"title":"FireDeferred​","type":1,"pageTitle":"Signal","url":"/Knit/api/Signal#FireDeferred","content":"&lt;/&gt; Signal:FireDeferred(...: any) → () Same as Fire, but uses task.defer internally &amp; doesn't take advantage of thread reuse. signal:FireDeferred(&quot;Hello&quot;)   "},{"title":"Wait​","type":1,"pageTitle":"Signal","url":"/Knit/api/Signal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Signal:Wait() → ...any Yields the current thread until the signal is fired, and returns the arguments fired from the signal. Yielding the current thread is not always desirable. If the desire is to only capture the next event fired, using Once might be a better solution. task.spawn(function() local msg, num = signal:Wait() print(msg, num) --&gt; &quot;Hello&quot;, 32 end) signal:Fire(&quot;Hello&quot;, 32)   "},{"title":"Destroy​","type":1,"pageTitle":"Signal","url":"/Knit/api/Signal#Destroy","content":"&lt;/&gt; Signal:Destroy() → () Cleans up the signal. Technically, this is only necessary if the signal is created usingSignal.Wrap. Connections should be properly GC'd once the signal is no longer referenced anywhere. However, it is still good practice to include ways to strictly clean up resources. Calling Destroy on a signal will also disconnect all connections immediately. signal:Destroy()   "},{"title":"ConnectOnce​","type":1,"pageTitle":"Signal","url":"/Knit/api/Signal#ConnectOnce","content":"deprecated in v1.3.0 &lt;/&gt; This was deprecated in v1.3.0 Use `Signal:Once` instead. Signal:ConnectOnce(fn: ConnectionFn) → SignalConnection  "},{"title":"Intellisense","type":0,"sectionRef":"#","url":"/Knit/docs/intellisense","content":"","keywords":""},{"title":"Custom Bootstrapper​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#custom-bootstrapper","content":"The verb &quot;bootstrapping&quot; in programming parlance is often used to describe a process that starts everything up (coming from the old phrase, &quot;pull yourself up by your bootstraps&quot;). In the context of Knit, this is usually handled internally when calling functions like Knit.CreateService() and Knit.Start(). This is ideal for a framework, as the users of the framework do not need to know the messy details of the startup procedure. The consequence of Knit taking control of the bootstrapping process is that all loaded services end up in a generic table (think of a bucket of assorted items). Due to the dynamic nature of this process, there is no way for Luau's type system to understand the type of a service simply based on the string name (e.g. Knit.GetService(&quot;HelloService&quot;); Luau can't statically understand that this is pointing to a specific service table). Thus, the question at hand is: How do we get Luau to understand the type of our service? "},{"title":"ModuleScripts Save the Day​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#modulescripts-save-the-day","content":"An important factor about Knit services is that they are just Lua tables with some extra items stuffed inside. This is why services are usually designed like any other module, with the exception that Knit.CreateService is called. Then, the resultant service is returned at the end of the ModuleScript. Because services are relatively statically defined, Roblox/Luau can understand its &quot;type&quot; if accessed directly. In other words, if the ModuleScript that the service lives inside is directly require'd, then intellisense would magically become available. Thus, the fix is to simply require the services directly from their corresponding ModuleScripts, side-stepping Knit's GetService calls entirely. -- Old way: local MyService = Knit.GetService(&quot;MyService&quot;) -- New way: local MyService = require(somewhere.MyService)  "},{"title":"Shifting the Problem​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#shifting-the-problem","content":"The problem, however, is that the call to CreateService messes it all up. Our day is ruined. Because CreateService is called within the ModuleScript, this messes up the &quot;type&quot; of the service. Thankfully, this is easy to fix. We simply need to remove our call to CreateService and instead call it within our custom bootstrap loader. We'll get to that in the next section. -- Old way: local SomeService = Knit.CreateService { Name = &quot;SomeService&quot;, } return SomeService -- New way; only getting rid of the Knit.CreateService call: local SomeService = { Name = &quot;SomeService&quot;, } return SomeService  Now, when our service is required, Luau will properly infer the type of the service, which will provide proper intellisense. However, we are no longer calling CreateService, which means our service is never registered within Knit, thus KnitStart and KnitInit never run. Oops. Let's fix this by writing our own service module loader. "},{"title":"Module Loader​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#module-loader","content":"Since we are no longer calling CreateService from the ModuleScript itself, our call to AddServices will no longer work as expected. Thus, we need to write our own version of AddServices that also calls CreateService on behalf of the module. local function AddServicesCustom(parent: Instance) -- For deep scan, switch GetChildren() to GetDescendants() for _, v in parent:GetChildren() do -- Only match on instances that are ModuleScripts and names that end with &quot;Service&quot;: if v:IsA(&quot;ModuleScript&quot;) and v.Name:match(&quot;Service$&quot;) then local service = require(v) -- Load the service module Knit.CreateService(service) -- Add the service into Knit end end end --Knit.AddServices(parent) (NO LONGER WILL WORK AS EXPECTED) AddServicesCustom(parent) Knit.Start()  Loader Module The Loader module can be used if you do not want to write your own loader function. local services = Loader.LoadChildren(parent, Loader.MatchesName(&quot;Service$&quot;)) for _, service in services do Knit.CreateService(service) end Knit.Start()  "},{"title":"Cyclical Dependencies​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#cyclical-dependencies","content":"When requiring modules directly, it is possible to run into cyclical dependency errors. In short, Roblox will not allow Module A to require Module B, which also then requires Module A. If A requires B, and B requires A, we have a cyclical dependency. This can happen in longer chains too (e.g. A-&gt;B-&gt;C-&gt;A). A side-effect of Knit's traditional startup procedure is that cyclical dependencies work fine. They work because modules are first loaded into memory before they grab any references to each other. Knit essentially acts as a bridge. However, this is an unintentional side-effect of Knit. Cyclical dependencies are a sign of poor architectural design. Knit does not seek to allow cyclical dependencies. Knit will not make any effort to allow them to exist. Their allowance is a byproduct of Knit's design. If you are running into cyclical dependency problems after switching to directly requiring services (i.e. using require instead of Knit.GetService), this is not an issue of Knit, but rather a code structure issue on your end. "},{"title":"Why Not the Default​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#why-not-the-default","content":"A fair question to ask is: Why is this not the preferred setup for Knit? Knit's various assertions are being side-stepped to allow intellisense to work.A lot of extra custom code has to be written.If you are willing to go to this length, then perhaps a custom-built framework would work better. "},{"title":"Client-accessed Services​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#client-accessed-services","content":"Services accessed from the client must still go through Knit.GetService, thus cannot benefit from this structural change. A secondary module could be used as the client-facing service module, but that would be a lot more work to maintain and handle. "},{"title":"Create-a-Knit​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#create-a-knit","content":"Creating your own framework like Knit is quite easy. In this short section, we will set up a simple module loader that works similar to Knit's startup procedure. However, it will lack networking capabilities. There are plenty of third-party networking libraries that can be used. Choosing which networking library to use is out of scope for this section. "},{"title":"Using the RbxUtil Loader Module​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#using-the-rbxutil-loader-module","content":"To help speed up this whole process, the Loader module will be utilized. This will help us quickly load our modules and kick off any sort of startup method per module. In keeping with the Service/Controller naming scheme, we will use the same names for our custom framework. "},{"title":"Loading Services​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#loading-services","content":"To load in our modules, we can call Loader.LoadChildren or Loader.LoadDescendants. This will go through and require all found ModuleScripts, returning them in a named dictionary table, where each key represents the name of the ModuleScript, and each value is the loaded value from the ModuleScript. local modules = Loader.LoadDescendants(ServerScriptService)  However, this isn't very useful, as we probably have a lot of non-service ModuleScripts in our codebase. The Loader module lets us filter which modules to use by passing in a predicate function. A helper MatchesName function generator can also be used to simply filter based on the name, which is what we will do. Let's load all ModuleScripts that end with the word &quot;Service&quot;: local services = Loader.LoadDescendants(ServerScriptService, Loader.MatchesName(&quot;Service$&quot;))  Great, so now we have a key/value table of loaded services! To mirror a bit of Knit, let's call the OnStart method of each service. "},{"title":"Starting Services​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#starting-services","content":"It's often useful to have a startup method that gets automatically called once all of our modules are loaded. This could be done by looping through each module and calling a method if it's found: for _, service in services do if typeof(service.OnStart) == &quot;function&quot; then task.spawn(function() service:OnStart() end) end end  That's a bit much. Thankfully, the Loader module also includes a SpawnAll function. This special function also calls debug.setmemorycategory so that we can properly profile the memory being used per OnStart service call: Loader.SpawnAll(services, &quot;OnStart&quot;)  "},{"title":"Final Loader Script​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#final-loader-script","content":"Let's merge all of the above code in one spot: -- ServerScriptService.ServerStartup local services = Loader.LoadDescendants(ServerScriptService, Loader.MatchesName(&quot;Service$&quot;)) Loader.SpawnAll(services, &quot;OnStart&quot;)  Our client-side code would look nearly identical. Just swap out the names. In this example, our controllers live in ReplicatedStorage: -- StarterPlayer.StarterPlayerScripts.ClientStartup local controllers = Loader.LoadDescendants(ReplicatedStorage, Loader.MatchesName(&quot;Controller$&quot;)) Loader.SpawnAll(controllers, &quot;OnStart&quot;)  "},{"title":"Example Services​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#example-services","content":"Due to this incredibly simple setup, our services are also very simple in structure; they're just tables within ModuleScripts. Nothing fancy. To use one service from another, simply require its ModuleScript. As such, intellisense comes natively baked in. -- ServerScriptService.MathService local MathService = {} function MathService:Add(a: number, b: number): number return a + b end return MathService  -- ServerScriptService.CalcService -- Simply require another service to use it: local MathService = require(somewhere.MathService) local CalcService = {} function CalcService:OnStart() local n1 = 10 local n2 = 20 local sum = MathService:Add(n1, n2) print(`Sum of {n1} and {n2} is {sum}`) end return CalcService  "},{"title":"Option","type":0,"sectionRef":"#","url":"/Knit/api/Option","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#properties","content":" "},{"title":"None​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#None","content":"&lt;/&gt; Option.None: Option&lt;None&gt; Represents no value. "},{"title":"Functions​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#functions","content":" "},{"title":"Some​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#Some","content":"&lt;/&gt; Option.Some(value: T) → Option&lt;T&gt; Creates an Option instance with the given value. Throws an error if the given value is nil.  "},{"title":"Wrap​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#Wrap","content":"&lt;/&gt; Option.Wrap(value: T) → Option&lt;T&gt; | Option&lt;None&gt; Safely wraps the given value as an option. If the value is nil, returns Option.None, otherwise returns Option.Some(value).  "},{"title":"Is​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#Is","content":"&lt;/&gt; Option.Is(obj: any) → boolean Returns true if obj is an Option.  "},{"title":"Assert​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#Assert","content":"&lt;/&gt; Option.Assert(obj: any) → () Throws an error if obj is not an Option.  "},{"title":"Deserialize​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#Deserialize","content":"&lt;/&gt; Option.Deserialize(data: table) → Option Deserializes the data into an Option. This data should have come from the option:Serialize() method.  "},{"title":"Serialize​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#Serialize","content":"&lt;/&gt; Option:Serialize() → table Returns a serialized version of the option.  "},{"title":"Match​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#Match","content":"&lt;/&gt; Option:Match(matches: { Some: (value: any) → any, None: () → any }) → any Matches against the option. local opt = Option.Some(32) opt:Match { Some = function(num) print(&quot;Number&quot;, num) end, None = function() print(&quot;No value&quot;) end, }   "},{"title":"IsSome​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#IsSome","content":"&lt;/&gt; Option:IsSome() → boolean Returns true if the option has a value.  "},{"title":"IsNone​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#IsNone","content":"&lt;/&gt; Option:IsNone() → boolean Returns true if the option is None.  "},{"title":"Expect​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#Expect","content":"&lt;/&gt; Option:Expect(msg: string) → value: any Unwraps the value in the option, otherwise throws an error with msg as the error message. local opt = Option.Some(10) print(opt:Expect(&quot;No number&quot;)) -&gt; 10 print(Option.None:Expect(&quot;No number&quot;)) -- Throws an error &quot;No number&quot;   "},{"title":"ExpectNone​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#ExpectNone","content":"&lt;/&gt; Option:ExpectNone(msg: string) → () Throws an error with msg as the error message if the value is not None.  "},{"title":"Unwrap​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#Unwrap","content":"&lt;/&gt; Option:Unwrap() → value: any Returns the value in the option, or throws an error if the option is None.  "},{"title":"UnwrapOr​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#UnwrapOr","content":"&lt;/&gt; Option:UnwrapOr(default: any) → value: any If the option holds a value, returns the value. Otherwise, returns default.  "},{"title":"UnwrapOrElse​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#UnwrapOrElse","content":"&lt;/&gt; Option:UnwrapOrElse(defaultFn: () → any) → value: any If the option holds a value, returns the value. Otherwise, returns the result of the defaultFn function.  "},{"title":"And​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#And","content":"&lt;/&gt; Option:And(optionB: Option) → Option Returns optionB if the calling option has a value, otherwise returns None. local optionA = Option.Some(32) local optionB = Option.Some(64) local opt = optionA:And(optionB) -- opt == optionB local optionA = Option.None local optionB = Option.Some(64) local opt = optionA:And(optionB) -- opt == Option.None   "},{"title":"AndThen​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#AndThen","content":"&lt;/&gt; Option:AndThen(andThenFn: (value: any) → Option) → value: Option If the option holds a value, then the andThenFn function is called with the held value of the option, and then the resultant Option returned by the andThenFn is returned. Otherwise, None is returned. local optA = Option.Some(32) local optB = optA:AndThen(function(num) return Option.Some(num * 2) end) print(optB:Expect(&quot;Expected number&quot;)) --&gt; 64   "},{"title":"Or​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#Or","content":"&lt;/&gt; Option:Or(optionB: Option) → Option If caller has a value, returns itself. Otherwise, returns optionB.  "},{"title":"OrElse​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#OrElse","content":"&lt;/&gt; Option:OrElse(orElseFn: () → Option) → Option If caller has a value, returns itself. Otherwise, returns the option generated by the orElseFn function.  "},{"title":"XOr​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#XOr","content":"&lt;/&gt; Option:XOr(optionB: Option) → Option If both self and optionB have values or both don't have a value, then this returns None. Otherwise, it returns the option that does have a value.  "},{"title":"Filter​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#Filter","content":"&lt;/&gt; Option:Filter(predicate: (value: any) → boolean) → Option Returns self if this option has a value and the predicate returns `true. Otherwise, returns None.  "},{"title":"Contains​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#Contains","content":"&lt;/&gt; Option:Contains(value: any) → boolean Returns true if this option contains value.  "},{"title":"__tostring​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#__tostring","content":"&lt;/&gt; Option:__tostring() → string Metamethod to transform the option into a string. local optA = Option.Some(64) local optB = Option.None print(optA) --&gt; Option&lt;number&gt; print(optB) --&gt; Option&lt;None&gt;   "},{"title":"__eq​","type":1,"pageTitle":"Option","url":"/Knit/api/Option#__eq","content":"&lt;/&gt; Option:__eq(opt: Option) → boolean Metamethod to check equality between two options. Returns true if both options hold the same value or both options are None. local o1 = Option.Some(32) local o2 = Option.Some(32) local o3 = Option.Some(64) local o4 = Option.None local o5 = Option.None print(o1 == o2) --&gt; true print(o1 == o3) --&gt; false print(o1 == o4) --&gt; false print(o4 == o5) --&gt; true  "},{"title":"Middleware","type":0,"sectionRef":"#","url":"/Knit/docs/middleware","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"Middleware","url":"/Knit/docs/middleware#usage","content":"Middleware is added when Knit is started: Knit.Start({Middleware = {Inbound = {...}, Outbound = {...}}}) or on each service. Each &quot;middleware&quot; item in the tables is a function. On the client, this function takes an array table containing all the arguments passed along. On the server, it is nearly the same, except the first argument before the arguments table is the player. Each function should return a boolean, indicating whether or not to continue to the request/response. If false, an optional variadic list of items can be returned, which will be returned back to the caller (essentially a short-circuit, but still returning data). Client middleware function signature: (args: {any}) -&gt; (boolean, ...)Server middleware function signature: (player: Player, args: {any}) -&gt; (boolean, ...) "},{"title":"Examples​","type":1,"pageTitle":"Middleware","url":"/Knit/docs/middleware#examples","content":"Logger​ Here's an example on the client which logs all inbound data from the server: local function Logger(args: { any }) print(args) return true end Knit.Start({ Middleware = { Inbound = { Logger } } })  Here's the same thing, but on the server. As you can see, the only difference is that the player argument is added to the middleware function: local function Logger(player: Player, args: { any }) print(player, args) return true end Knit.Start({ Middleware = { Inbound = { Logger } } })  Manipulation​ A more complex example, where any inbound number to the client is multiplied by 2: local function DoubleNumbers(args) for i, v in args do if type(v) == &quot;number&quot; then args[i] *= 2 end end return true end Knit.Start({ Middleware = { Inbound = { DoubleNumbers } } })  Per-Service Example​ Middleware can also be targeted per-service, which will override the global level middleware for the given service. -- Server-side: local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = {}, Middleware = { Inbound = { Logger }, Outbound = {}, }, }  On the client, things look a little different. Middleware is still per-service, not controller, so the definitions of per-service middleware need to go within Knit.Start() on the client: -- Client-side: Knit.Start({ PerServiceMiddleware = { -- Mapped by name of the service MyService = { Inbound = { Logger }, Outbound = {}, }, }, })  Serialization​ Another example, where a simple class is serialized/deserialized on the client before/after remote network communication occurs. A similar setup could be used server-side to complete the loop: ----------------------------------------------------- -- Setup a simple class: local MyClass = {} MyClass.__index = MyClass MyClass.ClassName = &quot;MyClass&quot; function MyClass.new() return setmetatable({ SomeData = &quot;&quot;, }, MyClass) end function MyClass:Serialize() return { _CN = self.ClassName, D = self.SomeData } end function MyClass.deserialize(data) local myClass = MyClass.new() myClass.SomeData = data return myClass end ----------------------------------------------------- -- Setup middleware for class serialization/deserialization on client: local function InboundClass(args) for i, v in args do if type(v) == &quot;table&quot; and v._CN == &quot;MyClass&quot; then args[i] = MyClass.deserialize(v) end end return true end local function OutboundClass(args) for i, v in args do if type(v) == &quot;table&quot; and v.ClassName == &quot;MyClass&quot; then args[i] = v:Serialize() end end return true end Knit.Start({ Middleware = { Inbound = { InboundClass }, Outbound = { OutboundClass }, }, })  "},{"title":"KnitServer","type":0,"sectionRef":"#","url":"/Knit/api/KnitServer","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#types","content":" "},{"title":"Middleware​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#Middleware","content":"&lt;/&gt; interface Middleware { Inbound: ServerMiddleware? Outbound: ServerMiddleware? }   "},{"title":"ServerMiddlewareFn​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#ServerMiddlewareFn","content":"&lt;/&gt; type ServerMiddlewareFn = ( player: Player , args: {any} ) → ( shouldContinue: boolean, ...: any ) For more info, see ServerComm documentation.  "},{"title":"ServerMiddleware​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#ServerMiddleware","content":"&lt;/&gt; type ServerMiddleware = {ServerMiddlewareFn} An array of server middleware functions.  "},{"title":"ServiceDef​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#ServiceDef","content":"&lt;/&gt; interface ServiceDef { Name: string Client: table? Middleware: Middleware? [any]: any } Used to define a service when creating it in CreateService. The middleware tables provided will be used instead of the Knit-level middleware (if any). This allows fine-tuning each service's middleware. These can also be left out or nil to not include middleware.  "},{"title":"Service​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#Service","content":"&lt;/&gt; interface Service { Name: string Client: ServiceClient KnitComm: Comm [any]: any }   "},{"title":"ServiceClient​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#ServiceClient","content":"&lt;/&gt; interface ServiceClient { Server: Service [any]: any }   "},{"title":"KnitOptions​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#KnitOptions","content":"&lt;/&gt; interface KnitOptions { Middleware: Middleware? }  Middleware will apply to all services except ones that define their own middleware.  "},{"title":"Properties​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#properties","content":" "},{"title":"Util​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#Util","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; KnitServer.Util: Folder  References the Util folder. Should only be accessed when using Knit as a standalone module. If using Knit from Wally, modules should just be pulled in via Wally instead of relying on Knit's Util folder, as this folder only contains what is necessary for Knit to run in Wally mode. "},{"title":"Functions​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#functions","content":" "},{"title":"CreateService​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#CreateService","content":"&lt;/&gt; KnitServer.CreateService(serviceDef: ServiceDef) → Service Constructs a new service. caution Services must be created before calling Knit.Start(). -- Create a service local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = {}, } -- Expose a ToAllCaps remote function to the clients function MyService.Client:ToAllCaps(player, msg) return msg:upper() end -- Knit will call KnitStart after all services have been initialized function MyService:KnitStart() print(&quot;MyService started&quot;) end -- Knit will call KnitInit when Knit is first started function MyService:KnitInit() print(&quot;MyService initialize&quot;) end   "},{"title":"AddServices​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#AddServices","content":"&lt;/&gt; KnitServer.AddServices(parent: Instance ) → {Service} Requires all the modules that are children of the given parent. This is an easy way to quickly load all services that might be in a folder. Knit.AddServices(somewhere.Services)   "},{"title":"AddServicesDeep​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#AddServicesDeep","content":"&lt;/&gt; KnitServer.AddServicesDeep(parent: Instance ) → {Service} Requires all the modules that are descendants of the given parent.  "},{"title":"GetService​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#GetService","content":"&lt;/&gt; KnitServer.GetService(serviceName: string) → Service Gets the service by name. Throws an error if the service is not found.  "},{"title":"GetServices​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#GetServices","content":"&lt;/&gt; KnitServer.GetServices() → {[string]: Service} Gets a table of all services.  "},{"title":"CreateSignal​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#CreateSignal","content":"&lt;/&gt; KnitServer.CreateSignal() → SIGNAL_MARKER Returns a marker that will transform the current key into a RemoteSignal once the service is created. Should only be called within the Client table of a service. See RemoteSignal documentation for more info. local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = { -- Create the signal marker, which will turn into a -- RemoteSignal when Knit.Start() is called: MySignal = Knit.CreateSignal(), }, } function MyService:KnitInit() -- Connect to the signal: self.Client.MySignal:Connect(function(player, ...) end) end   "},{"title":"CreateUnreliableSignal​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#CreateUnreliableSignal","content":"&lt;/&gt; KnitServer.CreateUnreliableSignal() → UNRELIABLE_SIGNAL_MARKER Returns a marker that will transform the current key into an unreliable RemoteSignal once the service is created. Should only be called within the Client table of a service. See RemoteSignal documentation for more info. Unreliable Events Internally, this uses UnreliableRemoteEvents, which allows for network communication that is unreliable and unordered. This is useful for events that are not crucial for gameplay, since the delivery of the events may occur out of order or not at all. See the documentation for UnreliableRemoteEvents for more info.  "},{"title":"CreateProperty​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#CreateProperty","content":"&lt;/&gt; KnitServer.CreateProperty(initialValue: any) → PROPERTY_MARKER Returns a marker that will transform the current key into a RemoteProperty once the service is created. Should only be called within the Client table of a service. An initial value can be passed along as well. RemoteProperties are great for replicating data to all of the clients. Different data can also be set per client. See RemoteProperty documentation for more info. local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = { -- Create the property marker, which will turn into a -- RemoteProperty when Knit.Start() is called: MyProperty = Knit.CreateProperty(&quot;HelloWorld&quot;), }, } function MyService:KnitInit() -- Change the value of the property: self.Client.MyProperty:Set(&quot;HelloWorldAgain&quot;) end   "},{"title":"Start​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#Start","content":"&lt;/&gt; KnitServer.Start(options: KnitServerOptions?) → Promise Starts Knit. Should only be called once. Optionally, KnitOptions can be passed in order to set Knit's custom configurations. caution Be sure that all services have been created before calling Start. Services cannot be added later. Knit.Start():andThen(function() print(&quot;Knit started!&quot;) end):catch(warn) Example of Knit started with options: Knit.Start({ Middleware = { Inbound = { function(player, args) print(&quot;Player is giving following args to server:&quot;, args) return true end }, }, }):andThen(function() print(&quot;Knit started!&quot;) end):catch(warn)   "},{"title":"OnStart​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#OnStart","content":"&lt;/&gt; KnitServer.OnStart() → Promise Returns a promise that is resolved once Knit has started. This is useful for any code that needs to tie into Knit services but is not the script that called Start. Knit.OnStart():andThen(function() local MyService = Knit.Services.MyService MyService:DoSomething() end):catch(warn)  "},{"title":"VS Code Snippets","type":0,"sectionRef":"#","url":"/Knit/docs/vscodesnippets","content":"","keywords":""},{"title":"Using Snippets​","type":1,"pageTitle":"VS Code Snippets","url":"/Knit/docs/vscodesnippets#using-snippets","content":"Snippets are a Visual Studio Code feature. Check out the Snippets documentation for more info. Adding Snippets for Lua is very easy. Within Visual Studio, navigate from the toolbar: File -&gt; Preferences -&gt; User SnippetsType in and select lua.jsonWithin the {} braces, include any or all of the snippets belowSave the fileWithin your actual source files, start typing a prefix (e.g. &quot;knit&quot;) and select the autocompleted snippet to paste it inDepending on the snippet, parts of the pasted code will be selected and can be typed over (e.g. setting the name of a service)  "},{"title":"Knit Snippets​","type":1,"pageTitle":"VS Code Snippets","url":"/Knit/docs/vscodesnippets#knit-snippets","content":"Below are useful VS Code snippets for Knit. The snippets assume that the Knit module has been placed within ReplicatedStorage. "},{"title":"Knit​","type":1,"pageTitle":"VS Code Snippets","url":"/Knit/docs/vscodesnippets#knit","content":"Include a require statement for Knit. Snippet &quot;Knit&quot;: { &quot;prefix&quot;: [&quot;knit&quot;], &quot;body&quot;: [&quot;local Knit = require(ReplicatedStorage.Packages.Knit)&quot;], &quot;description&quot;: &quot;Require the Knit module&quot; }  Code Result local Knit = require(ReplicatedStorage.Packages.Knit)   "},{"title":"Service​","type":1,"pageTitle":"VS Code Snippets","url":"/Knit/docs/vscodesnippets#service","content":"Reference a Roblox service. Snippet &quot;Service&quot;: { &quot;prefix&quot;: [&quot;service&quot;], &quot;body&quot;: [&quot;local ${0:Name}Service = game:GetService(\\&quot;${0:Name}Service\\&quot;)&quot;], &quot;description&quot;: &quot;Roblox Service&quot; }  Code Result local HttpService = game:GetService(&quot;HttpService&quot;)   "},{"title":"Knit Service​","type":1,"pageTitle":"VS Code Snippets","url":"/Knit/docs/vscodesnippets#knit-service","content":"Reference Knit, create a service, and return the service. Snippet &quot;Knit Service&quot;: { &quot;prefix&quot;: [&quot;knitservice&quot;], &quot;body&quot;: [ &quot;local Knit = require(ReplicatedStorage.Packages.Knit)&quot;, &quot;&quot;, &quot;local ${0:$TM_FILENAME_BASE} = Knit.CreateService {&quot;, &quot;\\tName = \\&quot;${0:$TM_FILENAME_BASE}\\&quot;,&quot;, &quot;\\tClient = {},&quot;, &quot;}&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitStart()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitInit()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Knit Service template&quot; }  Code Result local Knit = require(ReplicatedStorage.Packages.Knit) local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = {}, } function MyService:KnitStart() end function MyService:KnitInit() end return MyService   "},{"title":"Knit Controller​","type":1,"pageTitle":"VS Code Snippets","url":"/Knit/docs/vscodesnippets#knit-controller","content":"Reference Knit, create a controller, and return the controller. Snippet &quot;Knit Controller&quot;: { &quot;prefix&quot;: [&quot;knitcontroller&quot;], &quot;body&quot;: [ &quot;local Knit = require(ReplicatedStorage.Packages.Knit)&quot;, &quot;&quot;, &quot;local ${0:$TM_FILENAME_BASE} = Knit.CreateController { Name = \\&quot;${0:$TM_FILENAME_BASE}\\&quot; }&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitStart()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitInit()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Knit Controller template&quot; }  Code Result local Knit = require(ReplicatedStorage.Packages.Knit) local MyController = Knit.CreateController { Name = &quot;MyController&quot;, } function MyController:KnitStart() end function MyController:KnitInit() end return MyController   "},{"title":"Knit Require​","type":1,"pageTitle":"VS Code Snippets","url":"/Knit/docs/vscodesnippets#knit-require","content":"Require a module within Knit. Snippet &quot;Knit Require&quot;: { &quot;prefix&quot;: [&quot;knitrequire&quot;], &quot;body&quot;: [&quot;local ${1:Name} = require(Knit.${2:Util}.${1:Name})&quot;], &quot;description&quot;: &quot;Knit Require template&quot; }  Code Result local Signal = require(Knit.Util.Signal)   "},{"title":"Lua Class​","type":1,"pageTitle":"VS Code Snippets","url":"/Knit/docs/vscodesnippets#lua-class","content":"A standard Lua class. Snippet &quot;Class&quot;: { &quot;prefix&quot;: [&quot;class&quot;], &quot;body&quot;: [ &quot;local ${0:$TM_FILENAME_BASE} = {}&quot;, &quot;${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}.new()&quot;, &quot;\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})&quot;, &quot;\\treturn self&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:Destroy()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Lua Class&quot; }  Code Result local MyClass = {} MyClass.__index = MyClass function MyClass.new() local self = setmetatable({}, MyClass) return self end function MyClass:Destroy() end return MyClass   "},{"title":"All​","type":1,"pageTitle":"VS Code Snippets","url":"/Knit/docs/vscodesnippets#all","content":"All the above snippets together. All Snippets { &quot;Service&quot;: { &quot;prefix&quot;: [&quot;service&quot;], &quot;body&quot;: [&quot;local ${0:Name}Service = game:GetService(\\&quot;${0:Name}Service\\&quot;)&quot;], &quot;description&quot;: &quot;Roblox Service&quot; }, &quot;Class&quot;: { &quot;prefix&quot;: [&quot;class&quot;], &quot;body&quot;: [ &quot;local ${0:$TM_FILENAME_BASE} = {}&quot;, &quot;${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}.new()&quot;, &quot;\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})&quot;, &quot;\\treturn self&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:Destroy()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Lua Class&quot; }, &quot;Knit&quot;: { &quot;prefix&quot;: [&quot;knit&quot;], &quot;body&quot;: [&quot;local Knit = require(ReplicatedStorage.Packages.Knit)&quot;], &quot;description&quot;: &quot;Require the Knit module&quot; }, &quot;Knit Service&quot;: { &quot;prefix&quot;: [&quot;knitservice&quot;], &quot;body&quot;: [ &quot;local Knit = require(ReplicatedStorage.Packages.Knit)&quot;, &quot;&quot;, &quot;local ${0:$TM_FILENAME_BASE} = Knit.CreateService {&quot;, &quot;\\tName = \\&quot;${0:$TM_FILENAME_BASE}\\&quot;,&quot;, &quot;\\tClient = {},&quot;, &quot;}&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitStart()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitInit()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Knit Service template&quot; }, &quot;Knit Controller&quot;: { &quot;prefix&quot;: [&quot;knitcontroller&quot;], &quot;body&quot;: [ &quot;local Knit = require(ReplicatedStorage.Packages.Knit)&quot;, &quot;&quot;, &quot;local ${0:$TM_FILENAME_BASE} = Knit.CreateController { Name = \\&quot;${0:$TM_FILENAME_BASE}\\&quot; }&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitStart()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitInit()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Knit Controller template&quot; }, &quot;Knit Require&quot;: { &quot;prefix&quot;: [&quot;knitrequire&quot;], &quot;body&quot;: [&quot;local ${1:Name} = require(Knit.${2:Util}.${1:Name})&quot;], &quot;description&quot;: &quot;Knit Require template&quot; } }  "},{"title":"Promise","type":0,"sectionRef":"#","url":"/Knit/api/Promise","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#types","content":" "},{"title":"Status​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#Status","content":"enum &lt;/&gt; interface Status { Started: &quot;Started&quot;-- The Promise is executing, and not settled yet. Resolved: &quot;Resolved&quot;-- The Promise finished successfully. Rejected: &quot;Rejected&quot;-- The Promise was rejected. Cancelled: &quot;Cancelled&quot;-- The Promise was cancelled before it finished. } An enum value used to represent the Promise's status. "},{"title":"Properties​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#properties","content":" "},{"title":"Status​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#Status","content":"This item is read only and cannot be modified. Read Only enums &lt;/&gt; Promise.Status: Status A table containing all members of the Status enum, e.g., Promise.Status.Resolved. "},{"title":"Functions​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#new","content":"&lt;/&gt; Promise.new(executor: ( resolve: (...: any) → (), reject: (...: any) → (), onCancel: (abortHandler?: () → ()) → boolean ) → ()) → Promise Construct a new Promise that will be resolved or rejected with the given callbacks. If you resolve with a Promise, it will be chained onto. You can safely yield within the executor function and it will not block the creating thread. local myFunction() return Promise.new(function(resolve, reject, onCancel) wait(1) resolve(&quot;Hello world!&quot;) end) end myFunction():andThen(print) You do not need to use pcall within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If error() is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into Promise.Error(Promise.Error.Kind.ExecutionError) objects for tracking debug information. You may register an optional cancellation hook by using the onCancel argument: This should be used to abort any ongoing operations leading up to the promise being settled. Call the onCancel function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled. onCancel returns true if the Promise was already cancelled when you called onCancel. Calling onCancel with no argument will not override a previously set cancellation hook, but it will still return true if the Promise is currently cancelled. You can set the cancellation hook at any time before resolving. When a promise is cancelled, calls to resolve or reject will be ignored, regardless of if you set a cancellation hook or not. caution If the Promise is cancelled, the executor thread is closed with coroutine.close after the cancellation hook is called. You must perform any cleanup code in the cancellation hook: any time your executor yields, it may never resume.  "},{"title":"defer​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#defer","content":"&lt;/&gt; Promise.defer(executor: ( resolve: (...: any) → (), reject: (...: any) → (), onCancel: (abortHandler?: () → ()) → boolean ) → ()) → Promise The same as Promise.new, except execution begins after the next Heartbeat event. This is a spiritual replacement for spawn, but it does not suffer from the same issues as spawn. local function waitForChild(instance, childName, timeout) return Promise.defer(function(resolve, reject) local child = instance:WaitForChild(childName, timeout) ;(child and resolve or reject)(child) end) end   "},{"title":"resolve​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#resolve","content":"&lt;/&gt; Promise.resolve(...: any) → Promise&lt;...any&gt; Creates an immediately resolved Promise with the given value. -- Example using Promise.resolve to deliver cached values: function getSomething(name) if cache[name] then return Promise.resolve(cache[name]) else return Promise.new(function(resolve, reject) local thing = getTheThing() cache[name] = thing resolve(thing) end) end end   "},{"title":"reject​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#reject","content":"&lt;/&gt; Promise.reject(...: any) → Promise&lt;...any&gt; Creates an immediately rejected Promise with the given value. caution Something needs to consume this rejection (i.e. :catch() it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.  "},{"title":"try​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#try","content":"&lt;/&gt; Promise.try( callback: (...: T...) → ...any, ...: T...-- Additional arguments passed to callback ) → Promise Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback. info Promise.try is similar to Promise.promisify, except the callback is invoked immediately instead of returning a new function. Promise.try(function() return math.random(1, 2) == 1 and &quot;ok&quot; or error(&quot;Oh an error!&quot;) end) :andThen(function(text) print(text) end) :catch(function(err) warn(&quot;Something went wrong&quot;) end)   "},{"title":"all​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#all","content":"&lt;/&gt; Promise.all(promises: {Promise&lt;T&gt;}) → Promise&lt;{T}&gt; Accepts an array of Promises and returns a new promise that: is resolved after all input promises resolve. is rejected if any input promises reject. info Only the first return value from each promise will be present in the resulting array. After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.all(promises)   "},{"title":"fold​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#fold","content":"since v3.1.0 &lt;/&gt; Promise.fold( list: {T | Promise&lt;T&gt;}, reducer: ( accumulator: U, value: T, index: number ) → U | Promise&lt;U&gt;, initialValue: U ) → () Folds an array of values or promises into a single value. The array is traversed sequentially. The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value. The folding will stop at the first rejection encountered. local basket = {&quot;blueberry&quot;, &quot;melon&quot;, &quot;pear&quot;, &quot;melon&quot;} Promise.fold(basket, function(cost, fruit) if fruit == &quot;blueberry&quot; then return cost -- blueberries are free! else -- call a function that returns a promise with the fruit price return fetchPrice(fruit):andThen(function(fruitCost) return cost + fruitCost end) end end, 0)   "},{"title":"some​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#some","content":"&lt;/&gt; Promise.some( promises: {Promise&lt;T&gt;}, count: number ) → Promise&lt;{T}&gt; Accepts an array of Promises and returns a Promise that is resolved as soon as count Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers. count 0 results in an empty array. The resultant array will never have more than count elements. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve   "},{"title":"any​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#any","content":"&lt;/&gt; Promise.any(promises: {Promise&lt;T&gt;}) → Promise&lt;T&gt; Accepts an array of Promises and returns a Promise that is resolved as soon as any of the input Promises resolves. It will reject only if all input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers. Resolves directly with the value of the first resolved Promise. This is essentially [Promise.some] with 1 count, except the Promise resolves with the value directly instead of an array with one element. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)   "},{"title":"allSettled​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#allSettled","content":"&lt;/&gt; Promise.allSettled(promises: {Promise&lt;T&gt;}) → Promise&lt;{Status}&gt; Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping promise:finally over the array of Promises. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.allSettled(promises)   "},{"title":"race​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#race","content":"&lt;/&gt; Promise.race(promises: {Promise&lt;T&gt;}) → Promise&lt;T&gt; Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects. warning If the first Promise to settle from the array settles with a rejection, the resulting Promise from race will reject. If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use Promise.any or Promise.some instead. All other Promises that don't win the race will be cancelled if they have no other consumers. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.race(promises) -- Only returns 1st value to resolve or reject   "},{"title":"each​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#each","content":"since 3.0.0 &lt;/&gt; Promise.each( list: {T | Promise&lt;T&gt;}, predicate: ( value: T, index: number ) → U | Promise&lt;U&gt; ) → Promise&lt;{U}&gt; Iterates serially over the given an array of values, calling the predicate callback on each value before continuing. If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item in the array. info Promise.each is similar to Promise.all, except the Promises are ran in order instead of all at once. But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time. The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value. Promise.each({ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot; }, function(value, index) return Promise.delay(1):andThen(function() print((&quot;%d) Got %s!&quot;):format(index, value)) end) end) --[[ (1 second passes) &gt; 1) Got foo! (1 second passes) &gt; 2) Got bar! (1 second passes) &gt; 3) Got baz! (1 second passes) &gt; 4) Got qux! ]] If the Promise a predicate returns rejects, the Promise from Promise.each is also rejected with the same value. If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value. If a Promise in the array of values is already Rejected when Promise.each is called, Promise.each rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when Promise.each is called, Promise.each rejects with Promise.Error(Promise.Error.Kind.AlreadyCancelled). If a Promise in the array of values is Started at first, but later rejects, Promise.each will reject with that value and iteration will not continue once iteration encounters that value. Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values. If this Promise returned from Promise.each rejects or is cancelled for any reason, the following are true: Iteration will not continue. Any Promises within the array of values will now be cancelled if they have no other consumers. The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.  "},{"title":"is​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#is","content":"&lt;/&gt; Promise.is(object: any) → boolean-- true if the given object is a Promise. Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an andThen method.  "},{"title":"promisify​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#promisify","content":"&lt;/&gt; Promise.promisify(callback: (...: any) → ...any) → (...: any) → Promise Wraps a function that yields into one that returns a Promise. Any errors that occur while executing the function will be turned into rejections. info Promise.promisify is similar to Promise.try, except the callback is returned as a callable function instead of being invoked immediately. local sleep = Promise.promisify(wait) sleep(1):andThen(print) local isPlayerInGroup = Promise.promisify(function(player, groupId) return player:IsInGroup(groupId) end)   "},{"title":"delay​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#delay","content":"&lt;/&gt; Promise.delay(seconds: number) → Promise&lt;number&gt; Returns a Promise that resolves after seconds seconds have passed. The Promise resolves with the actual amount of time that was waited. This function is not a wrapper around wait. Promise.delay uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler. warning Passing NaN, infinity, or a number less than 1/60 is equivalent to passing 1/60. Promise.delay(5):andThenCall(print, &quot;This prints after 5 seconds&quot;)   "},{"title":"retry​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#retry","content":"since 3.0.0 &lt;/&gt; Promise.retry( callback: (...: P) → Promise&lt;T&gt;, times: number, ...?: P ) → Promise&lt;T&gt; Repeatedly calls a Promise-returning function up to times number of times, until the returned Promise resolves. If the amount of retries is exceeded, the function will return the latest rejected Promise. local function canFail(a, b, c) return Promise.new(function(resolve, reject) -- do something that can fail local failed, thing = doSomethingThatCanFail(a, b, c) if failed then reject(&quot;it failed&quot;) else resolve(thing) end end) end local MAX_RETRIES = 10 local value = Promise.retry(canFail, MAX_RETRIES, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;) -- args to send to canFail   "},{"title":"retryWithDelay​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#retryWithDelay","content":"since v3.2.0 &lt;/&gt; Promise.retryWithDelay( callback: (...: P) → Promise&lt;T&gt;, times: number, seconds: number, ...?: P ) → Promise&lt;T&gt; Repeatedly calls a Promise-returning function up to times number of times, waiting seconds seconds between each retry, until the returned Promise resolves. If the amount of retries is exceeded, the function will return the latest rejected Promise.  "},{"title":"fromEvent​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#fromEvent","content":"since 3.0.0 &lt;/&gt; Promise.fromEvent( event: Event,-- Any object with a Connect method. This includes all Roblox events. predicate?: (...: P) → boolean-- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again. ) → Promise&lt;P&gt; Converts an event into a Promise which resolves the next time the event fires. The optional predicate callback, if passed, will receive the event arguments and should return true or false, based on if this fired event should resolve the Promise or not. If true, the Promise resolves. If false, nothing happens and the predicate will be rerun the next time the event fires. The Promise will resolve with the event arguments. tip This function will work given any object with a Connect method. This includes all Roblox events. -- Creates a Promise which only resolves when `somePart` is touched -- by a part named `&quot;Something specific&quot;`. return Promise.fromEvent(somePart.Touched, function(part) return part.Name == &quot;Something specific&quot; end)   "},{"title":"onUnhandledRejection​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#onUnhandledRejection","content":"since v3.2.0 &lt;/&gt; Promise.onUnhandledRejection( callback: ( promise: Promise, ...: any )-- A callback that runs when an unhandled rejection happens. ) → () → ()-- Function that unregisters the callback when called Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise is rejected, and the rejection is not observed with :catch. The callback is called with the actual promise that rejected, followed by the rejection values.  "},{"title":"timeout​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#timeout","content":"&lt;/&gt; Promise:timeout( seconds: number, rejectionValue?: any-- The value to reject with if the timeout is reached ) → Promise Returns a new Promise that resolves if the chained Promise resolves within seconds seconds, or rejects if execution time exceeds seconds. The chained Promise will be cancelled if the timeout is reached. Rejects with rejectionValue if it is non-nil. If a rejectionValue is not given, it will reject with a Promise.Error(Promise.Error.Kind.TimedOut). This can be checked with [Error.isKind]. getSomething():timeout(5):andThen(function(something) -- got something and it only took at max 5 seconds end):catch(function(e) -- Either getting something failed or the time was exceeded. if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then warn(&quot;Operation timed out!&quot;) else warn(&quot;Operation encountered an error!&quot;) end end) Sugar for: Promise.race({ Promise.delay(seconds):andThen(function() return Promise.reject( rejectionValue == nil and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut }) or rejectionValue ) end), promise })   "},{"title":"getStatus​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#getStatus","content":"&lt;/&gt; Promise:getStatus() → Status Returns the current Promise status.  "},{"title":"andThen​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#andThen","content":"&lt;/&gt; Promise:andThen( successHandler: (...: any) → ...any, failureHandler?: (...: any) → ...any ) → Promise&lt;...any&gt; Chains onto an existing Promise and returns a new Promise. warning Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [Error] objects. If you want to treat it as a string for debugging, you should call tostring on it first. You can return a Promise from the success or failure handler and it will be chained onto. Calling andThen on a cancelled Promise returns a cancelled Promise. tip If the Promise returned by andThen is cancelled, successHandler and failureHandler will not run. To run code no matter what, use Promise:finally.  "},{"title":"catch​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#catch","content":"&lt;/&gt; Promise:catch(failureHandler: (...: any) → ...any) → Promise&lt;...any&gt; Shorthand for Promise:andThen(nil, failureHandler). Returns a Promise that resolves if the failureHandler worked without encountering an additional error. warning Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [Error] objects. If you want to treat it as a string for debugging, you should call tostring on it first. Calling catch on a cancelled Promise returns a cancelled Promise. tip If the Promise returned by catch is cancelled, failureHandler will not run. To run code no matter what, use Promise:finally.  "},{"title":"tap​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#tap","content":"&lt;/&gt; Promise:tap(tapHandler: (...: any) → ...any) → Promise&lt;...any&gt; Similar to Promise.andThen, except the return value is the same as the value passed to the handler. In other words, you can insert a :tap into a Promise chain without affecting the value that downstream Promises receive. getTheValue() :tap(print) :andThen(function(theValue) print(&quot;Got&quot;, theValue, &quot;even though print returns nil!&quot;) end) If you return a Promise from the tap handler callback, its value will be discarded but tap will still wait until it resolves before passing the original value through.  "},{"title":"andThenCall​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#andThenCall","content":"&lt;/&gt; Promise:andThenCall( callback: (...: any) → any, ...?: any-- Additional arguments which will be passed to callback ) → Promise Attaches an andThen handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded. promise:andThenCall(someFunction, &quot;some&quot;, &quot;arguments&quot;) This is sugar for promise:andThen(function() return someFunction(&quot;some&quot;, &quot;arguments&quot;) end)   "},{"title":"andThenReturn​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#andThenReturn","content":"&lt;/&gt; Promise:andThenReturn( ...: any-- Values to return from the function ) → Promise Attaches an andThen handler to this Promise that discards the resolved value and returns the given value from it. promise:andThenReturn(&quot;some&quot;, &quot;values&quot;) This is sugar for promise:andThen(function() return &quot;some&quot;, &quot;values&quot; end) caution Promises are eager, so if you pass a Promise to andThenReturn, it will begin executing before andThenReturn is reached in the chain. Likewise, if you pass a Promise created from [Promise.reject] into andThenReturn, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [Promise.andThen].  "},{"title":"cancel​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#cancel","content":"&lt;/&gt; Promise:cancel() → () Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled. Cancellations will propagate upwards and downwards through chained promises. Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call andThen twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled. promise:cancel()   "},{"title":"finally​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#finally","content":"&lt;/&gt; Promise:finally(finallyHandler: (status: Status) → ...any) → Promise&lt;...any&gt; Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, or cancelled. Returns a new Promise that: resolves with the same values that this Promise resolves with. rejects with the same values that this Promise rejects with. is cancelled if this Promise is cancelled. If the value you return from the handler is a Promise: We wait for the Promise to resolve, but we ultimately discard the resolved value. If the returned Promise rejects, the Promise returned from finally will reject with the rejected value from the returned promise. If the finally Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too. Otherwise, the return value from the finally handler is entirely discarded. Cancellation As of Promise v4, Promise:finally does not count as a consumer of the parent Promise for cancellation purposes. This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers, the Promise is cancelled and the finally callbacks run then and there. Cancellation still propagates through the finally Promise though: if you cancel the finally Promise, it can cancel its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the finally Promise will also be cancelled. local thing = createSomething() doSomethingWith(thing) :andThen(function() print(&quot;It worked!&quot;) -- do something.. end) :catch(function() warn(&quot;Oh no it failed!&quot;) end) :finally(function() -- either way, destroy thing thing:Destroy() end)   "},{"title":"finallyCall​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#finallyCall","content":"&lt;/&gt; Promise:finallyCall( callback: (...: any) → any, ...?: any-- Additional arguments which will be passed to callback ) → Promise Same as andThenCall, except for finally. Attaches a finally handler to this Promise that calls the given callback with the predefined arguments.  "},{"title":"finallyReturn​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#finallyReturn","content":"&lt;/&gt; Promise:finallyReturn( ...: any-- Values to return from the function ) → Promise Attaches a finally handler to this Promise that discards the resolved value and returns the given value from it. promise:finallyReturn(&quot;some&quot;, &quot;values&quot;) This is sugar for promise:finally(function() return &quot;some&quot;, &quot;values&quot; end)   "},{"title":"awaitStatus​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#awaitStatus","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:awaitStatus() → ( Status,-- The Status representing the fate of the Promise ...any-- The values the Promise resolved or rejected with. ) Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.  "},{"title":"await​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#await","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:await() → ( boolean,-- true if the Promise successfully resolved ...any-- The values the Promise resolved or rejected with. ) Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with. caution If the Promise gets cancelled, this function will return false, which is indistinguishable from a rejection. If you need to differentiate, you should use [Promise.awaitStatus] instead. local worked, value = getTheValue():await() if worked then print(&quot;got&quot;, value) else warn(&quot;it failed&quot;) end   "},{"title":"expect​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#expect","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:expect() → ...any-- The values the Promise resolved with. Yields the current thread until the given Promise completes. Returns the values that the promise resolved with. local worked = pcall(function() print(&quot;got&quot;, getTheValue():expect()) end) if not worked then warn(&quot;it failed&quot;) end This is essentially sugar for: select(2, assert(promise:await())) Errors if the Promise rejects or gets cancelled. "},{"title":"Errors","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise##","content":"Type\tDescriptionany\tErrors with the rejection value if this Promise rejects or gets cancelled.  "},{"title":"now​","type":1,"pageTitle":"Promise","url":"/Knit/api/Promise#now","content":"&lt;/&gt; Promise:now( rejectionValue?: any-- The value to reject with if the Promise isn't resolved ) → Promise Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling :now(). This can be used to ensure your andThen handler occurs on the same frame as the root Promise execution. doSomething() :now() :andThen(function(value) print(&quot;Got&quot;, value, &quot;synchronously.&quot;) end) If this Promise is still running, Rejected, or Cancelled, the Promise returned from :now() will reject with the rejectionValue if passed, otherwise with a Promise.Error(Promise.Error.Kind.NotResolvedInTime). This can be checked with [Error.isKind]. "},{"title":"Services","type":0,"sectionRef":"#","url":"/Knit/docs/services","content":"","keywords":""},{"title":"Services Defined​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#services-defined","content":"Services are singleton provider objects that serve a specific purpose on the server. For instance, a game might have a PointsService, which manages in-game points for the players. A game might have many services. They will serve as the backbone of a game. For the sake of example, we will slowly develop PointsService to show how a service is constructed. "},{"title":"Creating Services​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#creating-services","content":"In its simplest form, a service can be created like so: local PointsService = Knit.CreateService { Name = &quot;PointsService&quot;, Client = {} } return PointsService  Client table optional The Client table is optional for the constructor. However, it will be added by Knit if left out. For the sake of code clarity, it is recommended to keep it in the constructor as shown above. No client table forces server-only mode If the Client table is omitted, the service will be interpreted as server-side only. This means that the client will not be able to access this service using Knit.GetService on the client. The Name field is required. This name is how code outside of your service will find it. This name must be unique from all other services. It is best practice to name your variable the same as the service name (e.g. local PointsService matches Name = &quot;PointsService&quot;). The last line (return PointsService) assumes this code is written in a ModuleScript, which is best practice for containing services. "},{"title":"Adding methods​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#adding-methods","content":"Services are just simple tables at the end of the day. As such, it is very easy to add methods to services. function PointsService:AddPoints(player, amount) -- TODO: add points end function PointsService:GetPoints(player) return 0 end  "},{"title":"Adding properties​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#adding-properties","content":"Again, services are just tables. So we can simply add in properties as we want. In our above method, we are returning 0 for GetPoints() because we have nowhere to store/retrieve points. Likewise, our AddPoints() method can't do anything. Let's change that. Let's create a property that holds a table of points per player: PointsService.PointsPerPlayer = {}  "},{"title":"Using methods and properties​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#using-methods-and-properties","content":"Now we can change our AddPoints() and GetPoints() methods to use this field. PointsService.PointsPerPlayer = {} function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) -- Current amount of points points += amount -- Add points self.PointsPerPlayer[player] = points -- Store points end function PointsService:GetPoints(player) local points = self.PointsPerPlayer[player] return if points ~= nil then points else 0 -- Return 0 if no points found for player end  "},{"title":"Using events​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#using-events","content":"What if we want to fire an event when the amount of points changes? This is easy. We can assign an event named PointsChanged as a property of our service, and have our AddPoints() method fire the event: -- Load the Signal module and create PointsChanged signal: local Signal = require(Knit.Util.Signal) PointsService.PointsChanged = Signal.new() -- Modify AddPoints: function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) points += amount self.PointsPerPlayer[player] = points -- Fire event signal, as long as we actually changed the points: if amount ~= 0 then self.PointsChanged:Fire(player, points) end end  Another service could then listen for the changes on that event: function SomeOtherService:KnitStart() local PointsService = Knit.GetService(&quot;PointsService&quot;) PointsService.PointsChanged:Connect(function(player, points) print(&quot;Points changed for &quot; .. player.Name .. &quot;:&quot;, points) end) end  "},{"title":"KnitInit and KnitStart​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#knitinit-and-knitstart","content":"In that last code snippet, there's an odd KnitStart() method. This is part of the Knit lifecycle (read more under execution model). These methods are optional, but very useful for orchestrating communication between other services. When a service is first created, it is not guaranteed that other services are also created and ready to be used. The KnitInit and KnitStart methods come to save the day! After all services are created and the Knit.Start() method is fired, the KnitInit methods of all services will be fired. From the KnitInit method, we can guarantee that all other services have been created. However, we still cannot guarantee that those services are ready to be consumed. Therefore, we can reference them within the Init step, but we should never use them (e.g. use the methods or events attached to those other services). After all KnitInit methods have finished, all KnitStart methods are then fired. At this point, we can guarantee that all KnitInits are done, and thus can freely access other services. In order to maintain this pattern, be sure to set up your service in the Init method (or earlier; just in the ModuleScript itself). By the time KnitStart methods are being fired, your services should be available for use. "},{"title":"Cleaning Up Unused Memory​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#cleaning-up-unused-memory","content":"Alright, back to our PointsService! We have a problem... We have created a memory leak! When we add points for a player, we add the player to the table. What happens when the player leaves? Nothing! And that's a problem. That player's data is forever held onto within that PointsPerPlayer table. To fix this, we need to clear out that data when the player leaves. We can use the KnitInit method to hook up to the Players.PlayerRemoving event and remove the data: function PointsService:KnitInit() game:GetService(&quot;Players&quot;).PlayerRemoving:Connect(function(player) -- Clear out the data for the player when the player leaves: self.PointsPerPlayer[player] = nil end) end  While memory management is not unique to Knit, it is still an important aspect to consider when making your game. Even a garbage-collected language like Lua can have memory leaks introduced by the developer. "},{"title":"Client Communication​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#client-communication","content":"Alright, so we can store and add points on the server for a player. But who cares? Players have no visibility to these points at the moment. We need to open a line of communication between our service and the clients (AKA players). This functionality is so fundamental to Knit, that it's where the name came from: The need to knit together communication. This is where we are going to use that Client table defined at the beginning. "},{"title":"Methods​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#methods","content":"Let's say that we want to create a method that lets players fetch how many points they have, and when their points change. First, let's make a method to fetch points: function PointsService.Client:GetPoints(player) -- We can just call our other method from here: return self.Server:GetPoints(player) end  This creates a client-exposed method called GetPoints. Within it, we reach back to our top-level service using self.Server and then invoke our other GetPoints method that we wrote before. In this example, we've basically just created a proxy for another method; however, this will not always be the case. There will be many times where a client method will exist alone without an equivalent server-side-only method. Under the hood, Knit will create a RemoteFunction and bind this method to it. On the client, we could then invoke the service as such: -- From a LocalScript local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local PointsService = Knit.GetService(&quot;PointsService&quot;) PointsService:GetPoints():andThen(function(points) print(&quot;Points for myself:&quot;, points) end)  "},{"title":"Events (Server-to-Client)​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#events-server-to-client","content":"We can use remote signals to fire events from the server to the clients. Continuing with the previous PointsService example, let's create a signal that fires when a client's points change. We can use Knit.CreateSignal() to indicate we want a signal created for the service. local PointsService = Knit.CreateService { Name = &quot;PointsService&quot;, Client = { PointsChanged = Knit.CreateSignal(), -- Create the signal }, }  Remote Signal See the RemoteSignal documentation for more info on how to use the RemoteSignal object. Under the hood, Knit is using the Comm module, which is creating a RemoteEvent object linked to this event. This is a two-way signal (like a transceiver), so we can both send and receive data on both the server and the client. We can then modify our AddPoints method again to fire this signal too: function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) points += amount self.PointsPerPlayer[player] = points if amount ~= 0 then self.PointsChanged:Fire(player, points) -- Fire the client signal: self.Client.PointsChanged:Fire(player, points) end end  And from the client, we can listen for an event on the signal: -- From a LocalScript local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local PointsService = Knit.GetService(&quot;PointsService&quot;) PointsService.PointsChanged:Connect(function(points) print(&quot;Points for myself now:&quot;, points) end)  "},{"title":"Events (Client-to-Server)​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#events-client-to-server","content":"Signal events can also be fired from the client. This is useful when the client needs to give the server information, but doesn't care about any response from the server. For instance, maybe the client wants to tell the PointsService that it wants some points. This is an odd use-case, but let's just roll with it. We will create another client-exposed signal called GiveMePoints which will randomly give the player points. Again, this is nonsense in the context of an actual game, but useful for example. Let's create the signal on the PointsService: local PointsService = Knit.CreateService { Name = &quot;PointsService&quot;, Client = { PointsChanged = Knit.CreateSignal(), GiveMePoints = Knit.CreateSignal(), -- Create the new signal }, }  Now, let's listen for the client to fire this signal. We can hook this up in our KnitInit method: function PointsService:KnitInit() local rng = Random.new() -- Listen for the client to fire this signal, then give random points: self.Client.GiveMePoints:Connect(function(player) local points = rng:NextInteger(0, 10) self:AddPoints(player, points) print(&quot;Gave &quot; .. player.Name .. &quot; &quot; .. points .. &quot; points&quot;) end) -- ...other code for cleaning up player data here end  From the client, we can fire the signal like so: -- From a LocalScript local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local PointsService = Knit.GetService(&quot;PointsService&quot;) -- Fire the signal: PointsService.GiveMePoints:Fire()  Client Remote Signal See the ClientRemoteSignal documentation for more info on how to use the ClientRemoteSignal object. "},{"title":"Unreliable Events​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#unreliable-events","content":"Knit also supports UnreliableRemoteEvents, which is a special version of RemoteEvent. UnreliableRemoteEvents are, as the name suggests, unreliable. When an event is fired on an UnreliableRemoteEvent, the order and delivery of the event is not guaranteed. The listener of the event may receive the events out of order, or possibly not at all. Having unreliable events is useful in scenarios where the data being sent is not crucial to game state. For example, setting the tilt rotation of each avatar's head: if some packets are dropped, this won't affect actual gameplay. The benefit is that unreliable events take up less network bandwidth. To create an unreliable event, use Knit.CreateUnreliableSignal() within the client table of a service: local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = { PlayEffect = Knit.CreateUnreliableSignal(), }, }  Using the unreliable signal is the same as normal ones (see the two sections above on events). "},{"title":"Properties​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#properties","content":"It is often useful to replicate data to all or individual players. Instead of creating methods and signals to communicate this data, RemoteProperties can be used. For example, let's refactor the AddPoints method to set a RemoteProperty of the number of points the player has. The client will then be able to easily read this property: -- Create the RemoteProperty: PointsService.Client.Points = Knit.CreateProperty(0) function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) points += amount self.PointsPerPlayer[player] = points self.Client.Points:SetFor(player, points) end  On the client, we can now easily read the Points property: -- LocalScript local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local PointsService = Knit.GetService(&quot;PointsService&quot;) -- The 'Observe' method will fire for the current value and any time the value changes: PointsService.Points:Observe(function(points) print(&quot;Current number of points:&quot;, points) end)  Using Observe is the easiest way to track the value of a RemoteProperty on the client. Remote Property See the RemoteProperty andClientRemotePropertydocumentation for more info on how to use the RemoteProperty and ClientRemoteProperty objects.  "},{"title":"Full Example​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#full-example","content":""},{"title":"PointsService​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#pointsservice","content":"At the end of this tutorial, we should have a PointsService that looks something like this: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local Signal = require(Knit.Util.Signal) local PointsService = Knit.CreateService { Name = &quot;PointsService&quot;, -- Define some properties: PointsPerPlayer = {}, PointsChanged = Signal.new(), Client = { -- Expose signals to the client: PointsChanged = Knit.CreateSignal(), GiveMePoints = Knit.CreateSignal(), Points = Knit.CreateProperty(0), }, } -- Client exposed GetPoints method: function PointsService.Client:GetPoints(player) return self.Server:GetPoints(player) end -- Add Points: function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) points += amount self.PointsPerPlayer[player] = points if amount ~= 0 then self.PointsChanged:Fire(player, points) self.Client.PointsChanged:Fire(player, points) end self.Client.Points:SetFor(player, points) end -- Get Points: function PointsService:GetPoints(player) local points = self.PointsPerPlayer[player] return points or 0 end -- Initialize function PointsService:KnitInit() local rng = Random.new() -- Give player random amount of points: self.Client.GiveMePoints:Connect(function(player) local points = rng:NextInteger(0, 10) self:AddPoints(player, points) print(&quot;Gave &quot; .. player.Name .. &quot; &quot; .. points .. &quot; points&quot;) end) -- Clean up data when player leaves: game:GetService(&quot;Players&quot;).PlayerRemoving:Connect(function(player) self.PointsPerPlayer[player] = nil end) end return PointsService  "},{"title":"Client Consumer​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#client-consumer","content":"Example of client-side LocalScript consuming the PointsService: -- From a LocalScript local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) Knit.Start():catch(warn):await() local PointsService = Knit.GetService(&quot;PointsService&quot;) local function PointsChanged(points) print(&quot;My points:&quot;, points) end -- Get points and listen for changes: PointsService:GetPoints():andThen(PointsChanged) PointsService.PointsChanged:Connect(PointsChanged) -- Ask server to give points randomly: PointsService.GiveMePoints:Fire()  "}]